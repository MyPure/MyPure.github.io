<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MyPure&#39;s Blog Station</title>
  
  <subtitle>sqrt(-1) love you!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-02T08:53:47.869Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>My_Pure</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ 有序容器关键字类型的“严格弱序”</title>
    <link href="http://yoursite.com/2021/04/02/strict-weak-ordering/"/>
    <id>http://yoursite.com/2021/04/02/strict-weak-ordering/</id>
    <published>2021-04-02T08:37:05.000Z</published>
    <updated>2021-04-02T08:53:47.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有序容器中的关键字类型"><a href="#有序容器中的关键字类型" class="headerlink" title="有序容器中的关键字类型"></a>有序容器中的关键字类型</h2><p>当使用一些库函数时，会要求提供自定义的函数比较大小，或是类要重载<code>&lt;</code>运算符。该运算符需要有“严格弱序”（strict weak ordering）的性质。这个性质需要满足：</p><p>若两个关键字分别为<code>k1</code>，<code>k2</code>，符号为<code>&lt;</code>，则</p><p>若<code>k1&lt;k2</code>为<code>true</code>，则<code>k2&lt;k1</code>为<code>false</code>。</p><p>若<code>k1&lt;k2</code>且<code>k2&lt;k3</code>为<code>true</code>，则<code>k1&lt;k3</code>为<code>true</code>。</p><p>若<code>k1&lt;k2</code>为<code>false</code>且<code>k2&lt;k1</code>为<code>false</code>，称<code>k1</code>和<code>k2</code>等价，若<code>k1</code>和<code>k2</code>等价，<code>k2</code>和<code>k3</code>等价，则<code>k1</code>和<code>k3</code>等价。</p><h2 id="为什么要满足这个性质"><a href="#为什么要满足这个性质" class="headerlink" title="为什么要满足这个性质"></a>为什么要满足这个性质</h2><p>提供自定义的函数比较大小的时候，只需要提供一个判断便能得出两个变量的大小关系。而条件就是比较大小的运算符满足了“严格弱序”。</p><p>举个例子，数值比较的<code>&lt;</code>运算符就满足这个性质，而<code>&lt;=</code>不满足。当判断两个数值变量<code>i1</code>，<code>i2</code>是否相等时，是这样判断的：</p><p><code>!(i1&lt;i2) &amp;&amp; !(i2&lt;i1)</code>两个数字都不“严格弱序”于对方，相等。</p><p>如果把<code>&lt;</code>换成<code>&lt;=</code>，则会出现错误。因此，有序容器中的关键字类型比较需要满足“严格弱序”。</p><blockquote><p>C++ Primer P378</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;有序容器中的关键字类型&quot;&gt;&lt;a href=&quot;#有序容器中的关键字类型&quot; class=&quot;headerlink&quot; title=&quot;有序容器中的关键字类型&quot;&gt;&lt;/a&gt;有序容器中的关键字类型&lt;/h2&gt;&lt;p&gt;当使用一些库函数时，会要求提供自定义的函数比较大小，或是类要重载&lt;c
      
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>并查集介绍和模板</title>
    <link href="http://yoursite.com/2021/03/31/UnionFind/"/>
    <id>http://yoursite.com/2021/03/31/UnionFind/</id>
    <published>2021-03-31T04:36:25.000Z</published>
    <updated>2021-03-31T04:38:20.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>有关并查集的介绍：<a href="https://zhuanlan.zhihu.com/p/93647900/" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/93647900/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 当前连通分量数目</span></span><br><span class="line">    <span class="keyword">int</span> setCount;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> _n): n(_n), setCount(_n), parent(_n), size(_n, <span class="number">1</span>) &#123;</span><br><span class="line">        iota(parent.begin(), parent.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent[x] == x ? x : parent[x] = findset(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = findset(x);</span><br><span class="line">        y = findset(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">            swap(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        --setCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = findset(x);</span><br><span class="line">        y = findset(y);</span><br><span class="line">        <span class="keyword">return</span> x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h2&gt;&lt;p&gt;有关并查集的介绍：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/93647900/&quot; target=&quot;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>生涯首个独立游戏《Biphase》现已推出！</title>
    <link href="http://yoursite.com/2021/03/30/biphase/"/>
    <id>http://yoursite.com/2021/03/30/biphase/</id>
    <published>2021-03-29T16:00:00.000Z</published>
    <updated>2021-05-14T15:00:25.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生涯首个独立游戏《Biphase》现已推出！"><a href="#生涯首个独立游戏《Biphase》现已推出！" class="headerlink" title="生涯首个独立游戏《Biphase》现已推出！"></a>生涯首个独立游戏《Biphase》现已推出！</h2><p>《Biphase》是我作为主程序参与开发的一个由大学生团队独立研发的2D平台跳跃解谜游戏。现已在AppStore、GooglePlay、Steam上线，免费游玩！详情请见<a href="https://biphase.xoyo.games/index.html#/" target="_blank" rel="noopener">游戏官网</a>。</p><img src="/2021/03/30/biphase/biphase.png"> <img src="/2021/03/30/biphase/biphase2.png"> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;生涯首个独立游戏《Biphase》现已推出！&quot;&gt;&lt;a href=&quot;#生涯首个独立游戏《Biphase》现已推出！&quot; class=&quot;headerlink&quot; title=&quot;生涯首个独立游戏《Biphase》现已推出！&quot;&gt;&lt;/a&gt;生涯首个独立游戏《Biphase》现已推
      
    
    </summary>
    
    
      <category term="Game" scheme="http://yoursite.com/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>不用递归实现二叉树的前中后序遍历</title>
    <link href="http://yoursite.com/2021/03/28/TreeOrder/"/>
    <id>http://yoursite.com/2021/03/28/TreeOrder/</id>
    <published>2021-03-28T11:57:34.000Z</published>
    <updated>2021-03-31T04:36:26.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不用递归实现二叉树的前中后序遍历"><a href="#不用递归实现二叉树的前中后序遍历" class="headerlink" title="不用递归实现二叉树的前中后序遍历"></a>不用递归实现二叉树的前中后序遍历</h2><p>前序遍历和中序遍历类似，通过对一个栈的维护即可实现。后序遍历稍有不同，需要记录每一个节点是否访问过右子结点，若访问过则才会出栈并输出该结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line">TreeNode() : val(<span class="number">0</span>), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">TreeNode* cur = root;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">stack</span>.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="built_in">stack</span>.top()-&gt;right;</span><br><span class="line"><span class="built_in">stack</span>.pop();</span><br><span class="line">&#125; <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() || cur != <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">TreeNode* cur = root;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">stack</span>.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="built_in">stack</span>.top();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">cur = cur-&gt;right;</span><br><span class="line"><span class="built_in">stack</span>.pop();</span><br><span class="line">&#125; <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() || cur != <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">bool</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">TreeNode* cur = root;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">stack</span>.push(cur);</span><br><span class="line"><span class="built_in">map</span>[cur] = <span class="literal">false</span>;</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">map</span>[<span class="built_in">stack</span>.top()]) &#123;</span><br><span class="line"><span class="built_in">map</span>[<span class="built_in">stack</span>.top()] = <span class="literal">true</span>;</span><br><span class="line">cur = <span class="built_in">stack</span>.top()-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">stack</span>.top()-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">stack</span>.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() || cur != <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TreeNode* root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">root-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">root-&gt;left-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">root-&gt;left-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">root-&gt;left-&gt;right-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">root-&gt;left-&gt;right-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">root-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">root-&gt;right-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">root-&gt;right-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">preorder(root);</span><br><span class="line">inorder(root);</span><br><span class="line">postorder(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不用递归实现二叉树的前中后序遍历&quot;&gt;&lt;a href=&quot;#不用递归实现二叉树的前中后序遍历&quot; class=&quot;headerlink&quot; title=&quot;不用递归实现二叉树的前中后序遍历&quot;&gt;&lt;/a&gt;不用递归实现二叉树的前中后序遍历&lt;/h2&gt;&lt;p&gt;前序遍历和中序遍历类似，通过
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Unity 有关CanvasScaler缩放后的RectTransform坐标和屏幕坐标问题</title>
    <link href="http://yoursite.com/2021/01/04/About-CanvasScaler/"/>
    <id>http://yoursite.com/2021/01/04/About-CanvasScaler/</id>
    <published>2021-01-04T09:26:11.000Z</published>
    <updated>2021-01-04T09:34:26.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity-有关CanvasScaler缩放后的RectTransform坐标和屏幕坐标问题"><a href="#Unity-有关CanvasScaler缩放后的RectTransform坐标和屏幕坐标问题" class="headerlink" title="Unity 有关CanvasScaler缩放后的RectTransform坐标和屏幕坐标问题"></a>Unity 有关CanvasScaler缩放后的RectTransform坐标和屏幕坐标问题</h1><p>有的时候，我们希望通过直接设置RectTransform的值来进行UI的调整（例如anchoredPosition），但是由于CanvasScaler的缩放，屏幕坐标和Canvas内的坐标存在一个缩放关系。当想直接设置时，需要弄清楚CanvasScaler的缩放原理，找到坐标之间的对应关系。</p><p>有关CanvasScaler的介绍，可以参阅官方文档：</p><blockquote><p><a href="https://docs.unity.cn/cn/2019.4/Manual/script-CanvasScaler.html" target="_blank" rel="noopener">https://docs.unity.cn/cn/2019.4/Manual/script-CanvasScaler.html</a></p></blockquote><p>对于CanvasScaler的理解，可以认为：CanvasScaler的缩放是UI物体不变，画布的大小在变化（实际上也是这样，在缩小屏幕后，Canvas的RectTransform.rect会变大）。CanvasScaler的Match Width Or Height模式中，画布是根据当前屏幕大小和Reference Resolution设置的值进行比较，根据Match中的值来计算实际缩放因子。缩放因子可以通过如下代码计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float ScaleFactor =&gt; Screen.width / canvasScaler.referenceResolution.x * (1 - canvasScaler.matchWidthOrHeight) + Screen.height / canvasScaler.referenceResolution.y * canvasScaler.matchWidthOrHeight;</span><br></pre></td></tr></table></figure></p><p>含义是：Canvas内的UI被缩放成原来的UI乘以ScaleFactor的大小。<br>那么，当我们想通过anchoredPosition设置UI的值时，就需要将屏幕坐标除以ScalerFactor，就能计算出UI在画布内的实际坐标。<br>测试场景：<br>创建Canvas，将CanvasScaler的ScreenMatchMode设置为MatchWidthOrHeight。<br><img src="/2021/01/04/About-CanvasScaler/1.png"> </p><p>创建Image，设置RectTransform为锚点模式，并且将锚点设置在左下角。（为了直观与屏幕坐标对应，屏幕坐标的左下角为(0,0)）<br><img src="/2021/01/04/About-CanvasScaler/2.png">  </p><p>为Image创建脚本，完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line">using UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line">public class UIDragger : MonoBehaviour,IDragHandler</span><br><span class="line">&#123;</span><br><span class="line">    public Canvas canvas;</span><br><span class="line">    public CanvasScaler canvasScaler;</span><br><span class="line">    public RectTransform rectTransform;//Image的RectTransform</span><br><span class="line">    private float ScaleFactor =&gt; Screen.width / canvasScaler.referenceResolution.x * (1 - canvasScaler.matchWidthOrHeight) + Screen.height / canvasScaler.referenceResolution.y * canvasScaler.matchWidthOrHeight;</span><br><span class="line"></span><br><span class="line">    public void OnDrag(PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        rectTransform.anchoredPosition = eventData.position / ScaleFactor;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好引用后，开始场景，可以看到无论CanvasScaler的Match值设置成什么，都可以正常拖拽。</p><img src="/2021/01/04/About-CanvasScaler/1.gif">  <p>如果没有经过缩放因子的修正，效果是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rectTransform.anchoredPosition = eventData.position;</span><br></pre></td></tr></table></figure><img src="/2021/01/04/About-CanvasScaler/2.gif">  <p>后半段展示了关掉CanvasScaler的效果，实际上这个时候屏幕坐标就和画布坐标一一对应了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unity-有关CanvasScaler缩放后的RectTransform坐标和屏幕坐标问题&quot;&gt;&lt;a href=&quot;#Unity-有关CanvasScaler缩放后的RectTransform坐标和屏幕坐标问题&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
      <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Untiy 多平台宏定义</title>
    <link href="http://yoursite.com/2020/11/19/PlatformDependentCompilation/"/>
    <id>http://yoursite.com/2020/11/19/PlatformDependentCompilation/</id>
    <published>2020-11-19T08:03:54.000Z</published>
    <updated>2020-11-19T08:11:25.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity常用多平台宏定义"><a href="#Unity常用多平台宏定义" class="headerlink" title="Unity常用多平台宏定义"></a>Unity常用多平台宏定义</h1><table><thead><tr><th style="text-align:left"><strong>Define</strong></th><th style="text-align:left"><strong>Function</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>UNITY_EDITOR</strong></td><td style="text-align:left">#define directive to call Unity Editor scripts from your game code.</td></tr><tr><td style="text-align:left"><strong>UNITY_EDITOR_WIN</strong></td><td style="text-align:left">#define directive for Editor code on Windows.</td></tr><tr><td style="text-align:left"><strong>UNITY_EDITOR_OSX</strong></td><td style="text-align:left">#define directive for Editor code on Mac OS X.</td></tr><tr><td style="text-align:left"><strong>UNITY_EDITOR_LINUX</strong></td><td style="text-align:left">#define directive for Editor code on Linux.</td></tr><tr><td style="text-align:left"><strong>UNITY_STANDALONE_OSX</strong></td><td style="text-align:left">#define directive to compile or execute code specifically for Mac OS X (including Universal, PPC and Intel architectures).</td></tr><tr><td style="text-align:left"><strong>UNITY_STANDALONE_WIN</strong></td><td style="text-align:left">#define directive for compiling/executing code specifically for Windows standalone applications.</td></tr><tr><td style="text-align:left"><strong>UNITY_STANDALONE_LINUX</strong></td><td style="text-align:left">#define directive for compiling/executing code specifically for Linux standalone applications.</td></tr><tr><td style="text-align:left"><strong>UNITY_STANDALONE</strong></td><td style="text-align:left">#define directive for compiling/executing code for any standalone platform (Mac OS X, Windows or Linux).</td></tr><tr><td style="text-align:left"><strong>UNITY_WII</strong></td><td style="text-align:left">#define directive for compiling/executing code for the Wii console.</td></tr><tr><td style="text-align:left"><strong>UNITY_IOS</strong></td><td style="text-align:left">#define directive for compiling/executing code for the iOS platform.</td></tr><tr><td style="text-align:left"><strong>UNITY_ANDROID</strong></td><td style="text-align:left">#define directive for the Android platform.</td></tr><tr><td style="text-align:left"><strong>UNITY_PS4</strong></td><td style="text-align:left">#define directive for running <strong>PlayStation 4</strong>  code.</td></tr><tr><td style="text-align:left"><strong>UNITY_XBOXONE</strong></td><td style="text-align:left">#define directive for executing <strong>Xbox One</strong>  code.</td></tr><tr><td style="text-align:left"><strong>UNITY_LUMIN</strong></td><td style="text-align:left">#define directive for the Magic Leap OS platform. You can also use <strong>PLATFORM_LUMIN</strong>.</td></tr><tr><td style="text-align:left"><strong>UNITY_TIZEN</strong></td><td style="text-align:left">#define directive for the Tizen platform.</td></tr><tr><td style="text-align:left"><strong>UNITY_TVOS</strong></td><td style="text-align:left">#define directive for the Apple TV platform.</td></tr><tr><td style="text-align:left"><strong>UNITY_WSA</strong></td><td style="text-align:left">#define directive for <strong>Universal Windows Platform</strong> . Additionally, <strong>NETFX_CORE</strong> is defined when compiling C# files against .NET Core and using .NET <strong>scripting backend</strong> .</td></tr><tr><td style="text-align:left"><strong>UNITY_WSA_10_0</strong></td><td style="text-align:left">#define directive for Universal Windows Platform. Additionally <strong>WINDOWS_UWP</strong> is defined when compiling C# files against .NET Core.</td></tr><tr><td style="text-align:left"><strong>UNITY_WINRT</strong></td><td style="text-align:left">Same as <strong>UNITY_WSA</strong>.</td></tr><tr><td style="text-align:left"><strong>UNITY_WINRT_10_0</strong></td><td style="text-align:left">Equivalent to <strong>UNITY_WSA_10_0</strong></td></tr><tr><td style="text-align:left"><strong>UNITY_WEBGL</strong></td><td style="text-align:left">#define directive for <strong>WebGL</strong> .</td></tr><tr><td style="text-align:left"><strong>UNITY_FACEBOOK</strong></td><td style="text-align:left">#define directive for the Facebook platform (WebGL or Windows standalone).</td></tr><tr><td style="text-align:left"><strong>UNITY_ANALYTICS</strong></td><td style="text-align:left">#define directive for calling <strong>Unity Analytics</strong>  methods from your game code. Version 5.2 and above.</td></tr><tr><td style="text-align:left"><strong>UNITY_ASSERTIONS</strong></td><td style="text-align:left">#define directive for assertions control process.</td></tr><tr><td style="text-align:left"><strong>UNITY_64</strong></td><td style="text-align:left">#define directive for 64-bit platforms.</td></tr></tbody></table><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class PlatformDefines : MonoBehaviour &#123;</span><br><span class="line">  void Start () &#123;</span><br><span class="line">    #if UNITY_EDITOR</span><br><span class="line">        Debug.Log(&quot;Unity Editor&quot;);</span><br><span class="line">    #endif</span><br><span class="line">    </span><br><span class="line">    #if UNITY_IOS</span><br><span class="line">        Debug.Log(&quot;Iphone&quot;);</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    #if UNITY_STANDALONE_WIN</span><br><span class="line">     Debug.Log(&quot;Stand Alone Windows&quot;);</span><br><span class="line">    #endif</span><br><span class="line">        </span><br><span class="line">#if UNITY_EDITOR</span><br><span class="line">Debug.Log(&quot;Unity Editor&quot;);</span><br><span class="line">#elif UNITY_IOS</span><br><span class="line">Debug.Log(&quot;Unity iPhone&quot;);</span><br><span class="line">#else</span><br><span class="line">Debug.Log(&quot;Any other platform&quot;);</span><br><span class="line">#endif   </span><br><span class="line">  &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多，请详阅：</p><blockquote><p><a href="https://docs.unity3d.com/Manual/PlatformDependentCompilation.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/PlatformDependentCompilation.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unity常用多平台宏定义&quot;&gt;&lt;a href=&quot;#Unity常用多平台宏定义&quot; class=&quot;headerlink&quot; title=&quot;Unity常用多平台宏定义&quot;&gt;&lt;/a&gt;Unity常用多平台宏定义&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th styl
      
    
    </summary>
    
      <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
      <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>本科回顾</title>
    <link href="http://yoursite.com/2020/10/21/University-Days/"/>
    <id>http://yoursite.com/2020/10/21/University-Days/</id>
    <published>2020-10-21T13:32:07.000Z</published>
    <updated>2021-04-02T09:11:23.546Z</updated>
    
    <content type="html"><![CDATA[<h3 id="大一-2018-9-2019-6"><a href="#大一-2018-9-2019-6" class="headerlink" title="大一 2018.9~2019.6"></a>大一 2018.9~2019.6</h3><h5 id="Part1-初见"><a href="#Part1-初见" class="headerlink" title="Part1 初见"></a>Part1 初见</h5><p>怀揣着加入游戏行业梦想的我，进入了软件学院。<br>军训过后（大概是9月底），参加了软件学院科创团队的招新宣讲，报名了Game组。<br>团队给出了入门任务：实现一个双向链表的数据结构，带有增删改查等功能。<br>从0基础开始，在中秋和国庆期间自学C语言，完成了任务。<br>第二期任务是做一个贪吃蛇。突发奇想地想到了一个上下左右都相连的十字链表型数据结构，最终简单完成了在命令行上的贪吃蛇。可以说这是人生做的第一款游戏。<br><img src="/2020/10/21/University-Days/CLSnake.png"><br><a href="https://github.com/MyPure/Command-Line-Snake" title="命令行贪吃蛇小游戏" target="_blank" rel="noopener">https://github.com/MyPure/Command-Line-Snake</a><br>第三期任务是用Unity做一个简单的Demo。由于难度跨度太大，没能很好的完成，最后遗憾没有成功加入团队。</p><h5 id="Part2-熟悉"><a href="#Part2-熟悉" class="headerlink" title="Part2 熟悉"></a>Part2 熟悉</h5><p>C语言下发了祖传的贪吃蛇课设。又是贪吃蛇。有了之前的经验，这次我想做一个更好的贪吃蛇。带有图形化的界面，完整的游戏流程、UI、音乐贴图资源、更好的操控以及存档等功能。<br>没日没夜地做了一个多月，总算是完成了（半成品）。<br><img src="/2020/10/21/University-Days/Snake2.png"><br><img src="/2020/10/21/University-Days/Snake.png"><br><a href="https://github.com/MyPure/Snake" title="图形化贪吃蛇" target="_blank" rel="noopener">https://github.com/MyPure/Snake</a></p><h5 id="Part3-学习"><a href="#Part3-学习" class="headerlink" title="Part3 学习"></a>Part3 学习</h5><p>时间来到了大一下学期。<br>为了准备联创Game组的春招，我开始疯狂地学习C#和Unity。经过十几天的努力，我总算<del>完全掌握</del>入门了C#和Unity。<br>经过了笔试/面试/熬测/群面流程，最终成功进入了Game组。经过了一系列新人任务的洗礼，对Unity引擎Gameplay、计算机图形学、计算机网络都有了一点点入门和了解。<br>在这期间，参加了2019网易Minigame挑战赛，在差不多一个月的时间内和其他人合作完成了一个游戏Demo。<br>这是人生的第一个合作游戏作品。虽然没有成功晋级，但是却是一个很重要的开始。<br><a href="https://game.academy.163.com/activity/miniGame/2019/showcase/detail?id=79" title="minigame作品" target="_blank" rel="noopener">https://game.academy.163.com/activity/miniGame/2019/showcase/detail?id=79</a></p><h5 id="Part4-攀登"><a href="#Part4-攀登" class="headerlink" title="Part4 攀登"></a>Part4 攀登</h5><p>大一下学期结束后，迎来了软件学院的工程实训。<br>担任队长以及主程，使用Unity引擎，和队员一起完成了一个平台跳跃的小游戏。<br>由于先前有了经验，这次遇到的困难小了很多。第一次设计和实现了游戏的整体运行框架、游戏存档、游戏关卡、游戏UI等等。是一次很有意义的实践。<br><img src="/2020/10/21/University-Days/ygg1.png"><br><img src="/2020/10/21/University-Days/ygg2.png"><br><a href="https://github.com/MyPure/yuangungun" title="工程实训作品" target="_blank" rel="noopener">https://github.com/MyPure/yuangungun</a></p><h3 id="大二-2019-9-2020-6"><a href="#大二-2019-9-2020-6" class="headerlink" title="大二 2019.9~2020.6"></a>大二 2019.9~2020.6</h3><h5 id="Part1-课业"><a href="#Part1-课业" class="headerlink" title="Part1 课业"></a>Part1 课业</h5><p>大二的上学期课程量猛增。<br>数据结构，汇编语言，Java三门专业课，每一门都自带课设，有的还有附加的大作业。<br>这一年几乎是把所有的精力都放在了课业上，压根没怎么碰游戏开发。惭愧啊。<br>不过作为基础的数据结构还是很重要的。</p><h5 id="Part2-转变"><a href="#Part2-转变" class="headerlink" title="Part2 转变"></a>Part2 转变</h5><p>大二下学期，突如其来的疫情把所有人困在了家里。<br>正因如此拥有了大量充足的课余时间。<br>我开始着手准备今后用于面试的项目，也算是积累一些项目经验。<br>目光放在了小时候玩的一款flash游戏，叫做“海盗军团抢宝藏”，我打算用Unity做一个3D的复刻版。<br>从头开始，做游戏设计、系统设计、三维建模、Gameplay实现、网络编程等等，目标是做出一个完善且完整的项目。包含资源系统、战斗系统、网络系统、音效系统、武器系统、角色系统、地图系统、服务器等等……<br>是一个对编程能力和熟悉Unity引擎提升非常大的项目。</p><h5 id="Part3-里程碑"><a href="#Part3-里程碑" class="headerlink" title="Part3 里程碑"></a>Part3 里程碑</h5><p>大概五月，偶然在实习僧看到了一个叫做“西山居Seed训练营”的宣传。<br>刚好在做着项目，于是就投了简历试试。<br>大概过了半个多月，收到了面试通知，最后成功通过了。<br>这是一个非常有意义的时刻。算是职业生涯的起点了吧。<br><img src="/2020/10/21/University-Days/seasun.jpg"></p><p>训练营的内容是业内大佬上课以及自由组队做游戏。<br>作为主程，经过半个月和组内大佬们的努力，我们成功地把游戏做了出来，并且获得了最佳游戏奖。<br><img src="/2020/10/21/University-Days/seasungame.jpg"><br>西山居还会支持我们继续完善项目，直到最终完成并且上线。<br>这是一段非常宝贵的经历，不仅技术得到提升，而且能够有机会从业内的视角，进一步了解这个行业。<br>之后拿到了大三去西山居实习的Offer。</p><h3 id="大三-2020-9-2021-6"><a href="#大三-2020-9-2021-6" class="headerlink" title="大三 2020.9~2021.6"></a>大三 2020.9~2021.6</h3><h5 id="Part1-项目"><a href="#Part1-项目" class="headerlink" title="Part1 项目"></a>Part1 项目</h5><p>经历了大半年的开发，《双相》终于开发完，于2021.3.31上线了！</p><p>期间了解到游戏发行的很多方面，受益匪浅啊。</p><p>作为主程，也是第一次做独立游戏，还是遇到了非常多的困难。</p><p>多语言、多平台、手柄、音频、演出，都是我第一次接触，在慢慢摸索，自己搭建框架的过程中，克服困难的同时也确实学习到了很多。</p><img src="/2020/10/21/University-Days/google.png"><img src="/2020/10/21/University-Days/apple.png"><img src="/2020/10/21/University-Days/steam.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;大一-2018-9-2019-6&quot;&gt;&lt;a href=&quot;#大一-2018-9-2019-6&quot; class=&quot;headerlink&quot; title=&quot;大一 2018.9~2019.6&quot;&gt;&lt;/a&gt;大一 2018.9~2019.6&lt;/h3&gt;&lt;h5 id=&quot;Part1-初见&quot;
      
    
    </summary>
    
    
      <category term="career" scheme="http://yoursite.com/tags/career/"/>
    
  </entry>
  
  <entry>
    <title>UnityEditor</title>
    <link href="http://yoursite.com/2020/09/27/UnityEditor/"/>
    <id>http://yoursite.com/2020/09/27/UnityEditor/</id>
    <published>2020-09-27T07:57:59.000Z</published>
    <updated>2020-10-28T04:46:04.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UnityEditor扩展"><a href="#UnityEditor扩展" class="headerlink" title="UnityEditor扩展"></a>UnityEditor扩展</h2><h3 id="一、特性（Attribute）"><a href="#一、特性（Attribute）" class="headerlink" title="一、特性（Attribute）"></a>一、特性（Attribute）</h3><h5 id="1-1简介"><a href="#1-1简介" class="headerlink" title="1.1简介"></a>1.1简介</h5><p>特性是C#的一种“装饰”代码的方法，让我们可以为代码段标记一些信息，这样的信息又可从外部读取，并通过各种方式来影响我们所定义的类型的使用方式。添加特性的方式十分简单，将特性名称用中括号括起来，写在代码段前面即可。</p><h5 id="1-2创建特性"><a href="#1-2创建特性" class="headerlink" title="1.2创建特性"></a>1.2创建特性</h5><p>todo</p><h5 id="1-3Unity特性"><a href="#1-3Unity特性" class="headerlink" title="1.3Unity特性"></a>1.3Unity特性</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UnityEditor扩展&quot;&gt;&lt;a href=&quot;#UnityEditor扩展&quot; class=&quot;headerlink&quot; title=&quot;UnityEditor扩展&quot;&gt;&lt;/a&gt;UnityEditor扩展&lt;/h2&gt;&lt;h3 id=&quot;一、特性（Attribute）&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
      <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity_Plug-ins</title>
    <link href="http://yoursite.com/2019/09/09/Unity-Plug-ins/"/>
    <id>http://yoursite.com/2019/09/09/Unity-Plug-ins/</id>
    <published>2019-09-09T11:22:58.000Z</published>
    <updated>2020-11-26T14:37:40.699Z</updated>
    
    <content type="html"><![CDATA[<p>Behavior Designer 用于写AI </p><p>DoTween 用于补间 </p><p>PT</p><p>Default Playable 用于给Timeline添加更多类型的轨道</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Behavior Designer 用于写AI &lt;/p&gt;
&lt;p&gt;DoTween 用于补间 &lt;/p&gt;
&lt;p&gt;PT&lt;/p&gt;
&lt;p&gt;Default Playable 用于给Timeline添加更多类型的轨道&lt;/p&gt;

      
    
    </summary>
    
      <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
      <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>C#笔记</title>
    <link href="http://yoursite.com/2019/05/06/CSharp-Note/"/>
    <id>http://yoursite.com/2019/05/06/CSharp-Note/</id>
    <published>2019-05-06T05:10:22.000Z</published>
    <updated>2020-10-28T04:32:07.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串函数："><a href="#字符串函数：" class="headerlink" title="字符串函数："></a>字符串函数：</h3><pre><code>ToUpper();  ToLower();  Equals();比较//string变量1.Equals(string变量2);  Split();分割  Substring();截取  IndexOf();查找第一次出现  LastIndexOf();查找最后一次出现  StartsWith();判断是否以某字符串开始  EndsWith();判断是否以某字符串结束  Replace();替换  Contains();判断是否包含//string变量.Contains(string变量);  Trim();去掉空格//string变量.Trim();  TrimEnd();  TrimStart();  IsNullOrEmpty();判断字符串是Null还是空字符串//string.IsNullOrEmpty(string变量);  string.Format();字符串格式化  数组函数：Copyto(Array array,int index);//从指定的目标索引处开始复制当前数组至指定数组  StringBuilder类：using System.Text  StringBuilder 变量名 = new StringBuilder();  Append(string变量);追加  ToString();转为string  Clear();清空  Stopwatch类：using System.Diagnostics  Stopwatch 变量名 = new Stopwatch();  Start();开始  Stop();结束  Elapsed;开始到结束的时间  </code></pre><h3 id="ArrayList类：using-System-Collections"><a href="#ArrayList类：using-System-Collections" class="headerlink" title="ArrayList类：using System.Collections;"></a>ArrayList类：using System.Collections;</h3><pre><code>ArrayList 变量名 = new ArrayList();//初始化 System.Collections.ArrayList 类的新实例，该实例为空并且具有默认初始容量  ArrayList 变量名 = new ArrayList(int capacity);//初始化 System.Collections.ArrayList 类的新实例，该实例为空并且具有指定的初始容量  //capacity:新列表最初可以存储的元素数  ArrayList 变量名 = new ArrayList(ICollection c);//初始化 System.Collections.ArrayList 类的新实例，该类包含从指定集合复制的元素，并具有与复制的元素数相同的初始容量  // ICollection:一个接口，带有这个接口的变量都可以使用，例如Array（普通数组）或者ArrayList的对象  Add(object value); 将对象添加到 System.Collections.ArrayList 的结尾处  AddRange(ICollection c);将System.Collections.ICollection 的元素添加到System.Collections.ArrayList 的末尾  //添加新项后，集合中的项数就会增加，此时就可以通过像普通数组那样的常规方法使用集合中的项  Remove(object obj); 从 System.Collections.ArrayList 中移除特定对象的第一个匹配项  RemoveAt(int index); 移除 System.Collections.ArrayList 的指定索引处的元素  Reverse();将整个ArrayList反转  //可以用foreach迭代（遍历）普通数组，也可以迭代ArrayList，因为ArrayList实现了IEnumerable.  //要得到ArrayList元素的个数，需要使用Count属性.该属性由ICollection接口提供.  即：Arraylist变量.Count;  //ArrayList集合是System.Object对象的集合，所以使用每个实例元素前需要进行类型转换.  //这是一个集合类，事实上普通数组Array也是一个集合类.  </code></pre><h3 id="is和as"><a href="#is和as" class="headerlink" title="is和as"></a>is和as</h3><pre><code>对象变量 is 类; 如果是，值为true，否则值为false  对象变量 as 类;如果是，值为对象，否则为null  </code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><pre><code>[访问修饰符] class 类名{};  嵌套类：类可以嵌套  匿名类：不需要定义类就可以实例对象      var 对象名 = new {}      匿名类是只读的  密封类：不可以被继承的类      [访问修饰符] sealed class 类名{}      字段：类中的变量          [访问修饰符] 数据类型 字段名      属性：保护字段          public 数据类型(对应字段的) 属性名(与对应字段名保持一致，首字母大写)          {              get {return 字段名;}//取值              set {字段名 = value;}//赋值          }          自动属性              public 数据类型 属性名{get;set;}//自动属性不需要对应字段      方法：类中的函数          普通方法：普通的方法              [访问修饰符] 数据类型 方法名(参数){语句}          构造方法：对对象进行初始化，在实例化时调用              [访问修饰符] 类名(){语句}          析构方法：清理一个对象，系统自动调用          ~类名(){语句}  </code></pre><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><pre><code>    [访问修饰符] class 子类名:父类名{}    构造方法的继承        [访问修饰符] class 子类名:base(){}多态：子类继承父类后的多种形态，存在于继承前提下    虚方法        父类中：public virtual 类型 方法名(){}        子类中：public override 类型 方法名(){}    抽象类        abstract class 类名{}        抽象方法：无方法体的方法            public abstract 类型 方法名();//抽象类中不一定有抽象方法，但抽象方法必须在抽象类中  //抽象类的子类中必须重写抽象类中的所有抽象方法  //抽象类不可以实例化  </code></pre><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><pre><code>//一种类的形式，该类为抽象类且所有方法都是抽象方法  interface 接口名{}  //接口名一般为I开头  //接口中不能包含字段，但是可以使用属性（自动属性）  //接口中的成员没有访问修饰符，默认访问级别都是public  //接口中的方法都是抽象方法，没有方法体，但不需要用abstract关键字  //重写接口中的方法时不需要用override关键字  </code></pre><h4 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h4><pre><code>所有类都继承于object类，经常在类中重写ToString方法  </code></pre><h4 id="对象：由类实例化出来的具体事物"><a href="#对象：由类实例化出来的具体事物" class="headerlink" title="对象：由类实例化出来的具体事物"></a>对象：由类实例化出来的具体事物</h4><pre><code>类名 对象名 = new 类名();  对象初始化器      类名 对象名 = new 类名(){属性1=xxx,属性名2=xxx…}  </code></pre><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><pre><code>访问（类）      无或internal：只能在当前项目中访问类      public：可以在任何地方访问类  继承修饰符（类）      abstrac：不能实例化，只能被继承      sealed：不能被继承，只能实例化  访问（字段、属性、方法）      private：只能在本类中访问      public：任何地方都可以访问      internal：只能在本项目中访问      protected：只能在本类和子类中访问      protected internal：只能在本项目中的本类和子类中访问  </code></pre><h4 id="静态（static）"><a href="#静态（static）" class="headerlink" title="静态（static）"></a>静态（static）</h4><pre><code>静态属于类，而不属于实例对象  静态字段      [访问修饰符] static 数据类型 字段名      在定义字段的类型前加static关键字      静态字段只能用类名.字段名才可以访问，对象名.字段名无法访问      静态字段可以直接赋值      静态字段在内存中只存在一份（相当于全局变量）  静态属性      [访问修饰符] static 数据类型 属性名      只能用与封装静态字段  静态方法      [访问修饰符] static 类型 方法名{}      静态方法中不可以调用非静态方法  静态构造方法      static 类名(){}      静态构造方法用于初始化静态成员      一个类只能有一个静态构造方法，没有任何访问修饰符，没有参数      可以定义在静态类中，也可以定义在非静态类中      静态构造方法会在程序创建第一个实例或者引用任何静态成员之前被调用      不能直接调用，由系统调用  静态类      在class前添加static关键字      静态类中不能存在非静态成员      静态类不能实例化对象  </code></pre><h4 id="运算符重载：可以直接对对象使用运算符"><a href="#运算符重载：可以直接对对象使用运算符" class="headerlink" title="运算符重载：可以直接对对象使用运算符"></a>运算符重载：可以直接对对象使用运算符</h4><pre><code>给类中添加运算符类型成员：  public static 返回值类型 operator 运算符(参数列表){}  //成员必须是公开且静态的  //至少要有一个类类型的参数  可以重载的运算符：  一元：+,-,!,~,++,--,true,false  二元：+,-,*,/,%,&amp;,|,^,&lt;&lt;,&gt;&gt;  比较：==,!=,&lt;,&gt;,&lt;=,&gt;=  //如果重载true和false运算符，就可以在布尔表达式中使用类  //&gt;和&lt;,&lt;=和&gt;=必须成对重载  </code></pre><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><pre><code>1.    声明一个静态且私有的，当前类类型的字段  private static类名 instance;  2.    创建私有无参构造方法，保证外部无法实例化这个类  private 类名(){}  3.    创建一个该类类型的静态方法，用于创建此类的唯一对象  public static 类名 方法名(){    if(instance==null){      instance = new 类名();    }    return instance;  }  </code></pre><h3 id="面向对象原则"><a href="#面向对象原则" class="headerlink" title="面向对象原则"></a>面向对象原则</h3><h4 id="里式转换原则"><a href="#里式转换原则" class="headerlink" title="里式转换原则"></a>里式转换原则</h4><pre><code>1.子类对象可以直接赋值给父类类型变量  //接口和抽象类都不能直接实例化，但可以声明这些类型的变量  2.子类对象可以调用父类中的成员，但是父类对象只能调用自己的成员  3.如果父类对象中装的是子类对象，可以将这个父类对象强制转换为子类对象  </code></pre><p>#region 介绍<br>…  </p><p>#endregion  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;字符串函数：&quot;&gt;&lt;a href=&quot;#字符串函数：&quot; class=&quot;headerlink&quot; title=&quot;字符串函数：&quot;&gt;&lt;/a&gt;字符串函数：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;ToUpper();  
ToLower();  
Equals();比较//string变
      
    
    </summary>
    
      <category term="CSharp" scheme="http://yoursite.com/categories/CSharp/"/>
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hi</title>
    <link href="http://yoursite.com/2019/04/12/zhuzhu/"/>
    <id>http://yoursite.com/2019/04/12/zhuzhu/</id>
    <published>2019-04-12T15:44:02.000Z</published>
    <updated>2020-09-14T15:11:59.337Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="请输入密码查看文章" />    <label for="pass">请输入密码查看文章</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX18ttV8GnUxp2X8uRwIjyJ6tmoh6U2HWxzOLdGmKQP7mDllhPJT8OSJ1ShzHTD61biUfwQzKGtig6NCkJtFxsVYwUb7Zx7+y/3jbB1vIu7hLRegqSgiX/ZWwfG0JDWPOKoSCg360zFhAqplLxwlVaGCJJsYNrDaFmiMFhKXYqCGW1bjUGZE1Oca9ED3jm25Zz11ZwjjLYrREZFPkSMUPMESGazAp1vwIeOCYFNu4MZ2DbJQuHcv2pjeb/b7zF9FfOGkcCXP9GJxFhzmCFPyVQEOa8rozHoib28g0oOblDQ8TVqxcdXqDvPDM3zN1qdEwdWxaFQibg0zg0YewIT1k0atCFqpntH2phmxh1mXxAnw61yu0Nf00o75ypfGlstMryaq5UlAttZRPJwQZiRWeIseHc8weH+lKolSU6OjD+ZErqtGLdi01Bn+t2FVpptlvWLLUeCV19HBj+HuqWokwAc3T7HbBA3/DzX3G/Kzc3hG/BV0j3h2iBOTAFFV2r48VzQjtgIUPeMocVRk8pOONqeb83jfeYqm6IJ+jIWFYjDO+r0PzT+AhSfPVD10UbIJbhnDcFtfiznsQf8gJY2yg1jBRUDE1jlYp/apkl5CcAehhsbzIYx7pX1JydTgAMXIR/SC6nKEFj1/r59iJYabyX1kyPprVz8yMXUspl0nZKzpxl3bk3j8CbQdntJFdMb036yQTx74PEGvaDf65AFfNhcIG9LH0hgW9q1Woai1u8GjGPDCcE3elp5Jax37e+DvlsjhpxdmJfIC8yv/o5ZFA794hqzVFaUd34BeRvUqOW/iD2jmdeMwa3urXfryTLLP93hU6/vHhGSuoGaYbRFOZe/T4/fhaDdUV8aivrjJMdF1fPf/kDT7IwXWFK2D2byllnLBD1AuKqi169g==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      文章已加密
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux命令大全</title>
    <link href="http://yoursite.com/2019/04/12/linuxcommand/"/>
    <id>http://yoursite.com/2019/04/12/linuxcommand/</id>
    <published>2019-04-12T15:03:08.000Z</published>
    <updated>2019-04-12T15:13:35.785Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源 <a href="https://www.cnblogs.com/yjd_hycf_space/p/7730690.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjd_hycf_space/p/7730690.html</a></p></blockquote><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><p>arch 显示机器的处理器架构(1)<br>uname -m 显示机器的处理器架构(2)<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS   </p><h3 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h3><p>shutdown -h now 关闭系统(1)<br>init 0 关闭系统(2)<br>telinit 0 关闭系统(3)<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启(1)<br>reboot 重启(2)<br>logout 注销   </p><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls *[0-9]* 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构(1)<br>lstree 显示文件和目录由根目录开始的树形结构(2)<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.</p><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径   </p><h3 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h3><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享   </p><h3 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h3><p>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间    (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)   </p><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><p>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组   </p><h3 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><p>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位   </p><h3 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><p>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性   </p><h3 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h3><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包  </p><h3 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h3><p>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包  </p><h3 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h3><p>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件  </p><h3 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h3><p>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供  </p><h3 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h3><p>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称  </p><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><p>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;来源 &lt;a href=&quot;https://www.cnblogs.com/yjd_hycf_space/p/7730690.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/yj
      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C# IComparable和IComparer接口和自定义比较器</title>
    <link href="http://yoursite.com/2019/04/09/Compare/"/>
    <id>http://yoursite.com/2019/04/09/Compare/</id>
    <published>2019-04-09T08:36:21.000Z</published>
    <updated>2020-10-28T04:45:19.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ArrayList里面有一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public virtual void Sort(IComparer comparer);</span><br><span class="line">使用指定的比较器对整个 System.Collections.ArrayList 中的元素进行排序。</span><br><span class="line">comparer:比较元素时要使用的 System.Collections.IComparer 实现。</span><br></pre></td></tr></table></figure></p><p>啥玩意啊？</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="1-Comparer类简单介绍"><a href="#1-Comparer类简单介绍" class="headerlink" title="1.Comparer类简单介绍"></a>1.Comparer类简单介绍</h4><p>想弄清楚这个，我们先来看看这么一个类。<br>在System.Collections名称空间中，有这么一个类：Comparer。顾名思义，他可以实现对简单类型的比较，什么意思呢？来看如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a=1,b=2;</span><br></pre></td></tr></table></figure></p><p>正常情况下，我们要怎样比较他们的大小？if，运算符，……？这当然可以，不过Comparer已经给我们提供了一个函数，可以直接使用：（需要using System.Collections;）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(Comparer.Default.Compare(a,b));</span><br></pre></td></tr></table></figure></p><p>因为a&lt;b，所以控制台会输出-1。（这个函数总是返回-1，0，1三个值。）<br>这里通过Comparer里的静态属性Default获得Comparer的实例调用了Comparer里的非静态函数Compare。<br>（还可以比较根据字母比较两个string类型，这里就省略介绍了）</p><h4 id="2-自定义比较器，IComparable，IComparer接口"><a href="#2-自定义比较器，IComparable，IComparer接口" class="headerlink" title="2.自定义比较器，IComparable，IComparer接口"></a>2.自定义比较器，IComparable，IComparer接口</h4><p>当然，这个类不仅仅只是用来比较两个数的大小的。有时候我们想直接比较两个对象，但是引用里面的属性或许比较麻烦。尤其是参考要素过多，不好直接比较的时候，怎样才能更高效地比较两个对象呢？这时候，我们就需要自定义比较器了。<br>首先来介绍IComparable接口。这个接口里只有一个方法CompareTo()。让你的类实现这个接口的CompareTo方法，就可以直接调用这个方法和另一个对象比较。下面是例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ClassTest : IComparable</span><br><span class="line">&#123;</span><br><span class="line">  public int intTest;</span><br><span class="line">  public int CompareTo(object obj)</span><br><span class="line">  &#123;</span><br><span class="line">    return intTest-((ClassTest)obj).intTest;</span><br><span class="line">    //这里的代码可以按需要自己编写，这里只是一个简单的示例</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后就可以直接使用啦：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassTest a = new ClassTest()&#123;intTest=1&#125;;</span><br><span class="line">ClassTest b = new ClassTest()&#123;intTest=2&#125;;</span><br><span class="line">Console.WriteLine(a.CompareTo(b));//输出-1</span><br></pre></td></tr></table></figure></p><hr><p>Comparer类已经为我们提供了IComparer的默认实现，但我们仍然可以自定义它。新建一个类：（记得using System.Collections;）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ClassTestComparer : IComparer</span><br><span class="line">&#123;</span><br><span class="line">  public static IComparer Default = new ClassTestComparer();</span><br><span class="line">  //这里必须使用这样的定义，将对象转化为IComparer类型有很大用处，下面会介绍</span><br><span class="line">  public int Compare(object a,object b)</span><br><span class="line">  &#123;</span><br><span class="line">    return ((ClassTest)a).intTest - ((ClassTest)b).intTest;</span><br><span class="line">    //同样这里使用最简单的示例，但是你可以大放异彩</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，如果用于比较的类和设定的类不一样，就会出现错误。<br>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassTest a = new ClassTest()&#123;intTest=1&#125;;</span><br><span class="line">ClassTest b = new ClassTest()&#123;intTest=2&#125;;</span><br><span class="line">Console.WriteLine(ClassTestComparer.Default.Compare(a,b));</span><br><span class="line">//结果是-1</span><br></pre></td></tr></table></figure></p><hr><p>可以发现，这两个接口的不同之处在于：IComparable在要比较的对象的类中实现，可以比较该对象和另一个对象。IComparer在一个单独的类中实现，可以比较任意两个对象（关键是你的设置）。</p><h4 id="3-对集合排序"><a href="#3-对集合排序" class="headerlink" title="3.对集合排序"></a>3.对集合排序</h4><p>当然，这两个接口还有更强大的用处。我们可以使用这两个接口对集合进行排序。还记得前言里的Sort()方法吗？接下来就以ArrayList为例，介绍如何使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList ClassTests = new ArrayList();</span><br><span class="line">ClassTest a = new ClassTest()&#123;intTest=1&#125;;</span><br><span class="line">ClassTest b = new ClassTest()&#123;intTest=2&#125;;</span><br><span class="line">ClassTest c = new ClassTest()&#123;intTest=3&#125;;</span><br><span class="line">ClassTests.Add(a);</span><br><span class="line">ClassTests.Add(b);</span><br><span class="line">ClassTests.Add(c);</span><br><span class="line">ClassTests.Sort();</span><br><span class="line">//使用无参的Sort，将调用类中的CompareTo()方法，因为ClassTest实现了这个方法，所以是可以调用的。如果没有实现，编译器会报错。</span><br><span class="line">ClassTests.Sort(ClassTestComparer.Default);</span><br><span class="line">//这将使用Compare()方法对集合中的元素排序。ClassTestComparer类实现了这个方法，并且提供了一个IComparer类型的属性。</span><br></pre></td></tr></table></figure></p><p>需要注意的是：</p><ul><li>两个接口提供的方法返回值都是int类型的，负数代表小于，0代表等于，正数代表大于。所以对数字之外的自定义比较器，需要人工设定什么是“大”，什么是“小”。所以上文示例中两个数直接相减，就可以比较大小。</li><li>排序完之后，按照返回的int值，集合是由小到大排列的。</li><li>使用无参Sort()时，集合中至少要有一个类实现了IComparable，否则会报错。</li><li>一般来说，都是对同一个类进行比较。不过，也可以实现对不同类比较的代码，这就看具体需要了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ArrayList里面有一个方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="CSharp" scheme="http://yoursite.com/categories/CSharp/"/>
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList简介</title>
    <link href="http://yoursite.com/2019/04/09/ArrayList-Sketch/"/>
    <id>http://yoursite.com/2019/04/09/ArrayList-Sketch/</id>
    <published>2019-04-08T16:30:20.000Z</published>
    <updated>2020-10-28T04:45:04.640Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自《C#入门经典（第八版）》</p></blockquote><h2 id="ArrayList的概述"><a href="#ArrayList的概述" class="headerlink" title="ArrayList的概述"></a>ArrayList的概述</h2><p>我们知道的普通数组System.Array类实际上是集合类（Collection Class）的一种类型。集合类一般用于处理对象列表，其功能比简单数组要多，功能大多是通过实现System.Collections名称空间中的接口而获得的。而System.Collections.ArrayList类（以下简称ArrayList类）就是这样一种类，可以实现比Array类更多的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在vs中通过按住Alt左键点击ArrayList可以看到</span><br><span class="line">namespace System.Collections</span><br><span class="line">&#123;</span><br><span class="line">    public class ArrayList : IList, ICollection, IEnumerable, ICloneable</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到ArrayList类使用了IList, ICollection, IEnumerable, ICloneable这四个接口。这几个接口定义在System.Collections名称空间下。这些接口为类提供了基本的集合功能。<br><strong>在说明ArrayList的功能之前，有必要了解一下这几个接口。</strong></p><ul><li>IEnumerable——可以迭代（遍历）集合中的项（元素）。</li><li>ICollection——继承于IEnumerable。可以获取集合中项的个数，并能把项复制到一个简单的数组类型中。</li><li>IList——继承于ICollection和IEnumerable。提供了集合的项列表，允许访问这些项，并提供其他一些与项列表相关的基本功能。</li><li>ICloneable——克隆的支持，将创建的类的新实例得到与现有实例相同的值。<h2 id="ArrayList的使用"><a href="#ArrayList的使用" class="headerlink" title="ArrayList的使用"></a>ArrayList的使用</h2><strong>注意：ArrayList里的元素都是System.Object类型的。</strong></li></ul><p>ArrayList类实现了上述接口，但实现方式比System.Array类更复杂。这个类可用于表示可变大小的数组（或者称为集合）。接下来将简单介绍使用方法。<br><strong>使用ArrayList前，需要添加System.Collections名称空间。</strong><br><code>using System.Collections;</code></p><h5 id="创建一个ArrayList"><a href="#创建一个ArrayList" class="headerlink" title="创建一个ArrayList"></a>创建一个ArrayList</h5><p>ArrayList的构造函数有三个重载，下面逐一说明。<br>默认的构造函数是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayListTest = new ArrayList();</span><br></pre></td></tr></table></figure></p><p>可以发现，ArrayList不像普通数组那样需要指定数组的大小。<br>第二个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayListTest = new ArrayList(5);</span><br><span class="line">//这样创建的ArrayList默认有五个元素的容量，但这并不是绝对容量。</span><br></pre></td></tr></table></figure></p><p>第三个构造函数是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(ICollection c);</span><br><span class="line">//初始化 System.Collections.ArrayList 类的新实例，该类包含从指定集合复制的元素，并具有与复制的元素数相同的初始容量。</span><br><span class="line">//参数c:其元素已复制到新列表的 System.Collections.ICollection。</span><br></pre></td></tr></table></figure></p><p>可以看到c是一个ICollection类型的变量。也就是说，使用了ICollection接口的类的实例都可以当做参数c（没错，普通数组Array也可以，因为Array也使用了ICollection接口）。</p><p>所以我们可以这么用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayListTest2 = new ArrayList(arrayListTest);</span><br><span class="line">//这样创建直接复制了arrayListTest集合</span><br></pre></td></tr></table></figure></p><p>还可以这么用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] intTest = new int[5] &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">ArrayList arrayListTest2 = new ArrayList(intTest);</span><br></pre></td></tr></table></figure></p><h5 id="给ArrayList添加元素"><a href="#给ArrayList添加元素" class="headerlink" title="给ArrayList添加元素"></a>给ArrayList添加元素</h5><p>不像普通数组定义出来后就有了大小，ArrayList刚创建时是空的（一个元素都没有，除非你不是用的默认构造函数）。那么我们就需要给ArrayList添加元素了。添加元素需要使用ArrayList里的一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public virtual int Add(object value);</span><br><span class="line">//将value对象添加到ArrayList的结尾处。返回值为添加到ArrayList里的value的索引。</span><br></pre></td></tr></table></figure></p><p>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassTest classTestObject = new ClassTest();</span><br><span class="line">arrayListTest.Add(classTestObject);</span><br><span class="line">或者把以上两行代码二合一：</span><br><span class="line">arrayListTest.Add(new ClassTest());</span><br></pre></td></tr></table></figure></p><p>Add()方法只能在末尾添加一个元素。因此可以使用另一个方法一次性添加多个元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public virtual void AddRange(ICollection c);</span><br><span class="line">//将 ICollection 的元素添加到 System.Collections.ArrayList 的末尾。</span><br></pre></td></tr></table></figure></p><p>ICollection接口已在上文介绍，这里不再赘述。<br>给ArrayList添加元素后，ArrayList的长度（容量）就会自动增加。但是和Array不一样的是，读取ArrayList的长度需要使用ArrayList的Count属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(arrayListTest.Count);</span><br><span class="line">//将 System.Collections.ICollection 的元素添加到 System.Collections.ArrayList 的末尾。</span><br></pre></td></tr></table></figure></p><h5 id="使用ArrayList中的元素"><a href="#使用ArrayList中的元素" class="headerlink" title="使用ArrayList中的元素"></a>使用ArrayList中的元素</h5><p>添加完元素后，就可以使用里面的元素了。ArrayList可以像Array一样直接用下标索引使用元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassTest classTestObject2 = new ClassTest();</span><br><span class="line">arrayListTest[1] = classTestObject2;</span><br></pre></td></tr></table></figure></p><p>当然，索引ArrayList的下标也不能越界。<br>在使用ArrayList里的对象时，要注意：ArrayList集合是System.Object对象的集合，因此在使用对象成员时需要进行类型转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((ClassTest)arrayListTest[0]).FunctionTest();</span><br><span class="line">//FunctionTest()方法定义在ClassTest中。</span><br></pre></td></tr></table></figure></p><h5 id="删除ArrayList中的元素"><a href="#删除ArrayList中的元素" class="headerlink" title="删除ArrayList中的元素"></a>删除ArrayList中的元素</h5><p>使用如下方法可以删除ArrayList中的特定索引值的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayListTest.RemoveAt(0);</span><br><span class="line">//将删除下标为0的元素</span><br></pre></td></tr></table></figure></p><p>还可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayListTest.Remove(classTestObject);</span><br><span class="line">//删除arrayTest中的classTestObject对象</span><br></pre></td></tr></table></figure></p><p>删除某些元素后，这些元素后面的元素会自动前移。所以务必注意越界问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文参考自《C#入门经典（第八版）》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ArrayList的概述&quot;&gt;&lt;a href=&quot;#ArrayList的概述&quot; class=&quot;headerlink&quot; title=&quot;ArrayList的概述&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="CSharp" scheme="http://yoursite.com/categories/CSharp/"/>
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
