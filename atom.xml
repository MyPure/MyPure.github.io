<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MyPure&#39;s Blog Station</title>
  
  <subtitle>sqrt(-1) love you!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-12T19:31:22.014Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>My_Pure</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>McPicture</title>
    <link href="http://yoursite.com/2019/10/11/McPicture/"/>
    <id>http://yoursite.com/2019/10/11/McPicture/</id>
    <published>2019-10-11T04:41:37.000Z</published>
    <updated>2019-10-12T19:31:22.014Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/10/11/McPicture/1.jpeg">  <img src="/2019/10/11/McPicture/2.jpeg">  <img src="/2019/10/11/McPicture/3.jpg">  <img src="/2019/10/11/McPicture/6.jpg"><img src="/2019/10/11/McPicture/8.jpg"><img src="/2019/10/11/McPicture/9.jpg"><img src="/2019/10/11/McPicture/10.jpg"><img src="/2019/10/11/McPicture/11.jpg"> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/10/11/McPicture/1.jpeg&quot;&gt;  
&lt;img src=&quot;/2019/10/11/McPicture/2.jpeg&quot;&gt;  
&lt;img src=&quot;/2019/10/11/McPicture/3.jpg&quot;&gt;  
&lt;img src=&quot;/2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Unity_Plug-ins</title>
    <link href="http://yoursite.com/2019/09/09/Unity-Plug-ins/"/>
    <id>http://yoursite.com/2019/09/09/Unity-Plug-ins/</id>
    <published>2019-09-09T11:22:58.000Z</published>
    <updated>2019-10-12T11:16:01.812Z</updated>
    
    <content type="html"><![CDATA[<p>Behavior Designer 用于写AI<br>DoTween 用于补间<br>PT</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Behavior Designer 用于写AI&lt;br&gt;DoTween 用于补间&lt;br&gt;PT&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>C#笔记</title>
    <link href="http://yoursite.com/2019/05/06/C/"/>
    <id>http://yoursite.com/2019/05/06/C/</id>
    <published>2019-05-06T05:10:22.000Z</published>
    <updated>2019-05-06T06:24:11.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串函数："><a href="#字符串函数：" class="headerlink" title="字符串函数："></a>字符串函数：</h3><pre><code>ToUpper();  ToLower();  Equals();比较//string变量1.Equals(string变量2);  Split();分割  Substring();截取  IndexOf();查找第一次出现  LastIndexOf();查找最后一次出现  StartsWith();判断是否以某字符串开始  EndsWith();判断是否以某字符串结束  Replace();替换  Contains();判断是否包含//string变量.Contains(string变量);  Trim();去掉空格//string变量.Trim();  TrimEnd();  TrimStart();  IsNullOrEmpty();判断字符串是Null还是空字符串//string.IsNullOrEmpty(string变量);  string.Format();字符串格式化  数组函数：Copyto(Array array,int index);//从指定的目标索引处开始复制当前数组至指定数组  StringBuilder类：using System.Text  StringBuilder 变量名 = new StringBuilder();  Append(string变量);追加  ToString();转为string  Clear();清空  Stopwatch类：using System.Diagnostics  Stopwatch 变量名 = new Stopwatch();  Start();开始  Stop();结束  Elapsed;开始到结束的时间  </code></pre><h3 id="ArrayList类：using-System-Collections"><a href="#ArrayList类：using-System-Collections" class="headerlink" title="ArrayList类：using System.Collections;"></a>ArrayList类：using System.Collections;</h3><pre><code>ArrayList 变量名 = new ArrayList();//初始化 System.Collections.ArrayList 类的新实例，该实例为空并且具有默认初始容量  ArrayList 变量名 = new ArrayList(int capacity);//初始化 System.Collections.ArrayList 类的新实例，该实例为空并且具有指定的初始容量  //capacity:新列表最初可以存储的元素数  ArrayList 变量名 = new ArrayList(ICollection c);//初始化 System.Collections.ArrayList 类的新实例，该类包含从指定集合复制的元素，并具有与复制的元素数相同的初始容量  // ICollection:一个接口，带有这个接口的变量都可以使用，例如Array（普通数组）或者ArrayList的对象  Add(object value); 将对象添加到 System.Collections.ArrayList 的结尾处  AddRange(ICollection c);将System.Collections.ICollection 的元素添加到System.Collections.ArrayList 的末尾  //添加新项后，集合中的项数就会增加，此时就可以通过像普通数组那样的常规方法使用集合中的项  Remove(object obj); 从 System.Collections.ArrayList 中移除特定对象的第一个匹配项  RemoveAt(int index); 移除 System.Collections.ArrayList 的指定索引处的元素  Reverse();将整个ArrayList反转  //可以用foreach迭代（遍历）普通数组，也可以迭代ArrayList，因为ArrayList实现了IEnumerable.  //要得到ArrayList元素的个数，需要使用Count属性.该属性由ICollection接口提供.  即：Arraylist变量.Count;  //ArrayList集合是System.Object对象的集合，所以使用每个实例元素前需要进行类型转换.  //这是一个集合类，事实上普通数组Array也是一个集合类.  </code></pre><h3 id="is和as"><a href="#is和as" class="headerlink" title="is和as"></a>is和as</h3><pre><code>对象变量 is 类; 如果是，值为true，否则值为false  对象变量 as 类;如果是，值为对象，否则为null  </code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><pre><code>[访问修饰符] class 类名{};  嵌套类：类可以嵌套  匿名类：不需要定义类就可以实例对象      var 对象名 = new {}      匿名类是只读的  密封类：不可以被继承的类      [访问修饰符] sealed class 类名{}      字段：类中的变量          [访问修饰符] 数据类型 字段名      属性：保护字段          public 数据类型(对应字段的) 属性名(与对应字段名保持一致，首字母大写)          {              get {return 字段名;}//取值              set {字段名 = value;}//赋值          }          自动属性              public 数据类型 属性名{get;set;}//自动属性不需要对应字段      方法：类中的函数          普通方法：普通的方法              [访问修饰符] 数据类型 方法名(参数){语句}          构造方法：对对象进行初始化，在实例化时调用              [访问修饰符] 类名(){语句}          析构方法：清理一个对象，系统自动调用          ~类名(){语句}  </code></pre><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><pre><code>    [访问修饰符] class 子类名:父类名{}    构造方法的继承        [访问修饰符] class 子类名:base(){}多态：子类继承父类后的多种形态，存在于继承前提下    虚方法        父类中：public virtual 类型 方法名(){}        子类中：public override 类型 方法名(){}    抽象类        abstract class 类名{}        抽象方法：无方法体的方法            public abstract 类型 方法名();//抽象类中不一定有抽象方法，但抽象方法必须在抽象类中  //抽象类的子类中必须重写抽象类中的所有抽象方法  //抽象类不可以实例化  </code></pre><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><pre><code>//一种类的形式，该类为抽象类且所有方法都是抽象方法  interface 接口名{}  //接口名一般为I开头  //接口中不能包含字段，但是可以使用属性（自动属性）  //接口中的成员没有访问修饰符，默认访问级别都是public  //接口中的方法都是抽象方法，没有方法体，但不需要用abstract关键字  //重写接口中的方法时不需要用override关键字  </code></pre><h4 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h4><pre><code>所有类都继承于object类，经常在类中重写ToString方法  </code></pre><h4 id="对象：由类实例化出来的具体事物"><a href="#对象：由类实例化出来的具体事物" class="headerlink" title="对象：由类实例化出来的具体事物"></a>对象：由类实例化出来的具体事物</h4><pre><code>类名 对象名 = new 类名();  对象初始化器      类名 对象名 = new 类名(){属性1=xxx,属性名2=xxx…}  </code></pre><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><pre><code>访问（类）      无或internal：只能在当前项目中访问类      public：可以在任何地方访问类  继承修饰符（类）      abstrac：不能实例化，只能被继承      sealed：不能被继承，只能实例化  访问（字段、属性、方法）      private：只能在本类中访问      public：任何地方都可以访问      internal：只能在本项目中访问      protected：只能在本类和子类中访问      protected internal：只能在本项目中的本类和子类中访问  </code></pre><h4 id="静态（static）"><a href="#静态（static）" class="headerlink" title="静态（static）"></a>静态（static）</h4><pre><code>静态属于类，而不属于实例对象  静态字段      [访问修饰符] static 数据类型 字段名      在定义字段的类型前加static关键字      静态字段只能用类名.字段名才可以访问，对象名.字段名无法访问      静态字段可以直接赋值      静态字段在内存中只存在一份（相当于全局变量）  静态属性      [访问修饰符] static 数据类型 属性名      只能用与封装静态字段  静态方法      [访问修饰符] static 类型 方法名{}      静态方法中不可以调用非静态方法  静态构造方法      static 类名(){}      静态构造方法用于初始化静态成员      一个类只能有一个静态构造方法，没有任何访问修饰符，没有参数      可以定义在静态类中，也可以定义在非静态类中      静态构造方法会在程序创建第一个实例或者引用任何静态成员之前被调用      不能直接调用，由系统调用  静态类      在class前添加static关键字      静态类中不能存在非静态成员      静态类不能实例化对象  </code></pre><h4 id="运算符重载：可以直接对对象使用运算符"><a href="#运算符重载：可以直接对对象使用运算符" class="headerlink" title="运算符重载：可以直接对对象使用运算符"></a>运算符重载：可以直接对对象使用运算符</h4><pre><code>给类中添加运算符类型成员：  public static 返回值类型 operator 运算符(参数列表){}  //成员必须是公开且静态的  //至少要有一个类类型的参数  可以重载的运算符：  一元：+,-,!,~,++,--,true,false  二元：+,-,*,/,%,&amp;,|,^,&lt;&lt;,&gt;&gt;  比较：==,!=,&lt;,&gt;,&lt;=,&gt;=  //如果重载true和false运算符，就可以在布尔表达式中使用类  //&gt;和&lt;,&lt;=和&gt;=必须成对重载  </code></pre><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><pre><code>1.    声明一个静态且私有的，当前类类型的字段  private static类名 instance;  2.    创建私有无参构造方法，保证外部无法实例化这个类  private 类名(){}  3.    创建一个该类类型的静态方法，用于创建此类的唯一对象  public static 类名 方法名(){    if(instance==null){      instance = new 类名();    }    return instance;  }  </code></pre><h3 id="面向对象原则"><a href="#面向对象原则" class="headerlink" title="面向对象原则"></a>面向对象原则</h3><h4 id="里式转换原则"><a href="#里式转换原则" class="headerlink" title="里式转换原则"></a>里式转换原则</h4><pre><code>1.子类对象可以直接赋值给父类类型变量  //接口和抽象类都不能直接实例化，但可以声明这些类型的变量  2.子类对象可以调用父类中的成员，但是父类对象只能调用自己的成员  3.如果父类对象中装的是子类对象，可以将这个父类对象强制转换为子类对象  </code></pre><p>#region 介绍<br>…  </p><p>#endregion  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;字符串函数：&quot;&gt;&lt;a href=&quot;#字符串函数：&quot; class=&quot;headerlink&quot; title=&quot;字符串函数：&quot;&gt;&lt;/a&gt;字符串函数：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;ToUpper();  
ToLower();  
Equals();比较//string变
      
    
    </summary>
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hi 小公主</title>
    <link href="http://yoursite.com/2019/04/12/zhuzhu/"/>
    <id>http://yoursite.com/2019/04/12/zhuzhu/</id>
    <published>2019-04-12T15:44:02.000Z</published>
    <updated>2019-04-12T16:34:31.599Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="请输入密码查看文章" />    <label for="pass">请输入密码查看文章</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1/INcslMR5wY1xzdDW6QahTkCL36Xd9uAEzhZMOzCI70GF7VrABtZWMtQ8XJgxbo1mByyL4pc85cYcwI45wHW+iJkl5atMptDOzU7P5gBtKY1HX6PBODqKZrXPjIR0QcWF3acL/st9n7q12yDX76ft329O6zDutYlvq13K0byPv25LbRh0lCQ4SFsMWUlUwT3ve26YJ9LrJH+kHJAestHc0srha1YCu/74p2NrsfzBpQ4VPwvFWGXkQwTITtEtVekS+RUGB25z1ms7Eqs3RRgwz0OsE9K07zpwkEZXpkoPQJl1fxXK0ccSWR5ApZscbIXlduglhjrKc8gngB0rbwxIwH4WAZYINrT3icPmiwaRHek3cpQGVNUXDWxqnju1WZIgHdgJiYHMiSUhAHCg0Gu6eWjurvHCrmVxE+Tx3wCB7Wr/HecGi0pFmRs4hmMVtAJeUTr6W+FvHdAvqqQQPTh/8Ye8Dynn8gjwRZ3aqBQQTDF055FxUmlwPWg+52NcWRSZMcCccByG80WgqBczBenb/OL4aad2Hc/kwdsHmZKGOw9DUrLIS+lQfHk52EF4Eqc0d9CcoWlivFabHqY9ujkOk7uWFDb9rC/CdzbKBp29Ehv/+/GdkfcU5s9kYgSchuqBGh4HtY/lJxKWKThHfYmNLEjuaDOnVp2Utz2ksQeuyUrgvPVnw4D1mlUz3MFCi+h5BvQHoyo58LUveNS1f77WSRsnN9nkkECmHzgwrXiTTRlnk063QcJ1Fy1UNrFl3ckZNetssQBwmm16/pqoAjwuTZ8bpeJ6kwhu8eue+ACzMYR6OgiMiR9q06PqzasRFuxOpdDeFw8sd13MjX5axpuVVf6LWZibFNr85rVgRGqckAZTMpi5AHhZGBrKsI+o1HwdCYYZMfP1kOw==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      文章已加密
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux命令大全</title>
    <link href="http://yoursite.com/2019/04/12/linuxcommand/"/>
    <id>http://yoursite.com/2019/04/12/linuxcommand/</id>
    <published>2019-04-12T15:03:08.000Z</published>
    <updated>2019-04-12T15:13:35.785Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源 <a href="https://www.cnblogs.com/yjd_hycf_space/p/7730690.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjd_hycf_space/p/7730690.html</a></p></blockquote><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><p>arch 显示机器的处理器架构(1)<br>uname -m 显示机器的处理器架构(2)<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS   </p><h3 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h3><p>shutdown -h now 关闭系统(1)<br>init 0 关闭系统(2)<br>telinit 0 关闭系统(3)<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启(1)<br>reboot 重启(2)<br>logout 注销   </p><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls *[0-9]* 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构(1)<br>lstree 显示文件和目录由根目录开始的树形结构(2)<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.</p><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径   </p><h3 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h3><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享   </p><h3 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h3><p>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间    (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)   </p><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><p>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组   </p><h3 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><p>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位   </p><h3 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><p>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性   </p><h3 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h3><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包  </p><h3 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h3><p>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包  </p><h3 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h3><p>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件  </p><h3 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h3><p>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供  </p><h3 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h3><p>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称  </p><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><p>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;来源 &lt;a href=&quot;https://www.cnblogs.com/yjd_hycf_space/p/7730690.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/yj
      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C# IComparable和IComparer接口和自定义比较器</title>
    <link href="http://yoursite.com/2019/04/09/Compare/"/>
    <id>http://yoursite.com/2019/04/09/Compare/</id>
    <published>2019-04-09T08:36:21.000Z</published>
    <updated>2019-04-12T15:06:08.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ArrayList里面有一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public virtual void Sort(IComparer comparer);</span><br><span class="line">使用指定的比较器对整个 System.Collections.ArrayList 中的元素进行排序。</span><br><span class="line">comparer:比较元素时要使用的 System.Collections.IComparer 实现。</span><br></pre></td></tr></table></figure></p><p>啥玩意啊？</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="1-Comparer类简单介绍"><a href="#1-Comparer类简单介绍" class="headerlink" title="1.Comparer类简单介绍"></a>1.Comparer类简单介绍</h4><p>想弄清楚这个，我们先来看看这么一个类。<br>在System.Collections名称空间中，有这么一个类：Comparer。顾名思义，他可以实现对简单类型的比较，什么意思呢？来看如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a=1,b=2;</span><br></pre></td></tr></table></figure></p><p>正常情况下，我们要怎样比较他们的大小？if，运算符，……？这当然可以，不过Comparer已经给我们提供了一个函数，可以直接使用：（需要using System.Collections;）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(Comparer.Default.Compare(a,b));</span><br></pre></td></tr></table></figure></p><p>因为a&lt;b，所以控制台会输出-1。（这个函数总是返回-1，0，1三个值。）<br>这里通过Comparer里的静态属性Default获得Comparer的实例调用了Comparer里的非静态函数Compare。<br>（还可以比较根据字母比较两个string类型，这里就省略介绍了）</p><h4 id="2-自定义比较器，IComparable，IComparer接口"><a href="#2-自定义比较器，IComparable，IComparer接口" class="headerlink" title="2.自定义比较器，IComparable，IComparer接口"></a>2.自定义比较器，IComparable，IComparer接口</h4><p>当然，这个类不仅仅只是用来比较两个数的大小的。有时候我们想直接比较两个对象，但是引用里面的属性或许比较麻烦。尤其是参考要素过多，不好直接比较的时候，怎样才能更高效地比较两个对象呢？这时候，我们就需要自定义比较器了。<br>首先来介绍IComparable接口。这个接口里只有一个方法CompareTo()。让你的类实现这个接口的CompareTo方法，就可以直接调用这个方法和另一个对象比较。下面是例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ClassTest : IComparable</span><br><span class="line">&#123;</span><br><span class="line">  public int intTest;</span><br><span class="line">  public int CompareTo(object obj)</span><br><span class="line">  &#123;</span><br><span class="line">    return intTest-((ClassTest)obj).intTest;</span><br><span class="line">    //这里的代码可以按需要自己编写，这里只是一个简单的示例</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后就可以直接使用啦：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassTest a = new ClassTest()&#123;intTest=1&#125;;</span><br><span class="line">ClassTest b = new ClassTest()&#123;intTest=2&#125;;</span><br><span class="line">Console.WriteLine(a.CompareTo(b));//输出-1</span><br></pre></td></tr></table></figure></p><hr><p>Comparer类已经为我们提供了IComparer的默认实现，但我们仍然可以自定义它。新建一个类：（记得using System.Collections;）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ClassTestComparer : IComparer</span><br><span class="line">&#123;</span><br><span class="line">  public static IComparer Default = new ClassTestComparer();</span><br><span class="line">  //这里必须使用这样的定义，将对象转化为IComparer类型有很大用处，下面会介绍</span><br><span class="line">  public int Compare(object a,object b)</span><br><span class="line">  &#123;</span><br><span class="line">    return ((ClassTest)a).intTest - ((ClassTest)b).intTest;</span><br><span class="line">    //同样这里使用最简单的示例，但是你可以大放异彩</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，如果用于比较的类和设定的类不一样，就会出现错误。<br>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassTest a = new ClassTest()&#123;intTest=1&#125;;</span><br><span class="line">ClassTest b = new ClassTest()&#123;intTest=2&#125;;</span><br><span class="line">Console.WriteLine(ClassTestComparer.Default.Compare(a,b));</span><br><span class="line">//结果是-1</span><br></pre></td></tr></table></figure></p><hr><p>可以发现，这两个接口的不同之处在于：IComparable在要比较的对象的类中实现，可以比较该对象和另一个对象。IComparer在一个单独的类中实现，可以比较任意两个对象（关键是你的设置）。</p><h4 id="3-对集合排序"><a href="#3-对集合排序" class="headerlink" title="3.对集合排序"></a>3.对集合排序</h4><p>当然，这两个接口还有更强大的用处。我们可以使用这两个接口对集合进行排序。还记得前言里的Sort()方法吗？接下来就以ArrayList为例，介绍如何使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList ClassTests = new ArrayList();</span><br><span class="line">ClassTest a = new ClassTest()&#123;intTest=1&#125;;</span><br><span class="line">ClassTest b = new ClassTest()&#123;intTest=2&#125;;</span><br><span class="line">ClassTest c = new ClassTest()&#123;intTest=3&#125;;</span><br><span class="line">ClassTests.Add(a);</span><br><span class="line">ClassTests.Add(b);</span><br><span class="line">ClassTests.Add(c);</span><br><span class="line">ClassTests.Sort();</span><br><span class="line">//使用无参的Sort，将调用类中的CompareTo()方法，因为ClassTest实现了这个方法，所以是可以调用的。如果没有实现，编译器会报错。</span><br><span class="line">ClassTests.Sort(ClassTestComparer.Default);</span><br><span class="line">//这将使用Compare()方法对集合中的元素排序。ClassTestComparer类实现了这个方法，并且提供了一个IComparer类型的属性。</span><br></pre></td></tr></table></figure></p><p>需要注意的是：</p><ul><li>两个接口提供的方法返回值都是int类型的，负数代表小于，0代表等于，正数代表大于。所以对数字之外的自定义比较器，需要人工设定什么是“大”，什么是“小”。所以上文示例中两个数直接相减，就可以比较大小。</li><li>排序完之后，按照返回的int值，集合是由小到大排列的。</li><li>使用无参Sort()时，集合中至少要有一个类实现了IComparable，否则会报错。</li><li>一般来说，都是对同一个类进行比较。不过，也可以实现对不同类比较的代码，这就看具体需要了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ArrayList里面有一个方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hi</title>
    <link href="http://yoursite.com/2019/04/09/Hi/"/>
    <id>http://yoursite.com/2019/04/09/Hi/</id>
    <published>2019-04-08T16:48:28.000Z</published>
    <updated>2019-04-09T03:45:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I’m-MyPure"><a href="#I’m-MyPure" class="headerlink" title="I’m MyPure."></a>I’m MyPure.</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;I’m-MyPure&quot;&gt;&lt;a href=&quot;#I’m-MyPure&quot; class=&quot;headerlink&quot; title=&quot;I’m MyPure.&quot;&gt;&lt;/a&gt;I’m MyPure.&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="你好" scheme="http://yoursite.com/tags/%E4%BD%A0%E5%A5%BD/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList简介</title>
    <link href="http://yoursite.com/2019/04/09/ArrayList-Sketch/"/>
    <id>http://yoursite.com/2019/04/09/ArrayList-Sketch/</id>
    <published>2019-04-08T16:30:20.000Z</published>
    <updated>2019-04-09T08:48:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自《C#入门经典（第八版）》</p></blockquote><h2 id="ArrayList的概述"><a href="#ArrayList的概述" class="headerlink" title="ArrayList的概述"></a>ArrayList的概述</h2><p>我们知道的普通数组System.Array类实际上是集合类（Collection Class）的一种类型。集合类一般用于处理对象列表，其功能比简单数组要多，功能大多是通过实现System.Collections名称空间中的接口而获得的。而System.Collections.ArrayList类（以下简称ArrayList类）就是这样一种类，可以实现比Array类更多的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在vs中通过按住Alt左键点击ArrayList可以看到</span><br><span class="line">namespace System.Collections</span><br><span class="line">&#123;</span><br><span class="line">    public class ArrayList : IList, ICollection, IEnumerable, ICloneable</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到ArrayList类使用了IList, ICollection, IEnumerable, ICloneable这四个接口。这几个接口定义在System.Collections名称空间下。这些接口为类提供了基本的集合功能。<br><strong>在说明ArrayList的功能之前，有必要了解一下这几个接口。</strong></p><ul><li>IEnumerable——可以迭代（遍历）集合中的项（元素）。</li><li>ICollection——继承于IEnumerable。可以获取集合中项的个数，并能把项复制到一个简单的数组类型中。</li><li>IList——继承于ICollection和IEnumerable。提供了集合的项列表，允许访问这些项，并提供其他一些与项列表相关的基本功能。</li><li>ICloneable——克隆的支持，将创建的类的新实例得到与现有实例相同的值。<h2 id="ArrayList的使用"><a href="#ArrayList的使用" class="headerlink" title="ArrayList的使用"></a>ArrayList的使用</h2><strong>注意：ArrayList里的元素都是System.Object类型的。</strong></li></ul><p>ArrayList类实现了上述接口，但实现方式比System.Array类更复杂。这个类可用于表示可变大小的数组（或者称为集合）。接下来将简单介绍使用方法。<br><strong>使用ArrayList前，需要添加System.Collections名称空间。</strong><br><code>using System.Collections;</code></p><h5 id="创建一个ArrayList"><a href="#创建一个ArrayList" class="headerlink" title="创建一个ArrayList"></a>创建一个ArrayList</h5><p>ArrayList的构造函数有三个重载，下面逐一说明。<br>默认的构造函数是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayListTest = new ArrayList();</span><br></pre></td></tr></table></figure></p><p>可以发现，ArrayList不像普通数组那样需要指定数组的大小。<br>第二个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayListTest = new ArrayList(5);</span><br><span class="line">//这样创建的ArrayList默认有五个元素的容量，但这并不是绝对容量。</span><br></pre></td></tr></table></figure></p><p>第三个构造函数是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(ICollection c);</span><br><span class="line">//初始化 System.Collections.ArrayList 类的新实例，该类包含从指定集合复制的元素，并具有与复制的元素数相同的初始容量。</span><br><span class="line">//参数c:其元素已复制到新列表的 System.Collections.ICollection。</span><br></pre></td></tr></table></figure></p><p>可以看到c是一个ICollection类型的变量。也就是说，使用了ICollection接口的类的实例都可以当做参数c（没错，普通数组Array也可以，因为Array也使用了ICollection接口）。</p><p>所以我们可以这么用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayListTest2 = new ArrayList(arrayListTest);</span><br><span class="line">//这样创建直接复制了arrayListTest集合</span><br></pre></td></tr></table></figure></p><p>还可以这么用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] intTest = new int[5] &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">ArrayList arrayListTest2 = new ArrayList(intTest);</span><br></pre></td></tr></table></figure></p><h5 id="给ArrayList添加元素"><a href="#给ArrayList添加元素" class="headerlink" title="给ArrayList添加元素"></a>给ArrayList添加元素</h5><p>不像普通数组定义出来后就有了大小，ArrayList刚创建时是空的（一个元素都没有，除非你不是用的默认构造函数）。那么我们就需要给ArrayList添加元素了。添加元素需要使用ArrayList里的一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public virtual int Add(object value);</span><br><span class="line">//将value对象添加到ArrayList的结尾处。返回值为添加到ArrayList里的value的索引。</span><br></pre></td></tr></table></figure></p><p>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassTest classTestObject = new ClassTest();</span><br><span class="line">arrayListTest.Add(classTestObject);</span><br><span class="line">或者把以上两行代码二合一：</span><br><span class="line">arrayListTest.Add(new ClassTest());</span><br></pre></td></tr></table></figure></p><p>Add()方法只能在末尾添加一个元素。因此可以使用另一个方法一次性添加多个元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public virtual void AddRange(ICollection c);</span><br><span class="line">//将 ICollection 的元素添加到 System.Collections.ArrayList 的末尾。</span><br></pre></td></tr></table></figure></p><p>ICollection接口已在上文介绍，这里不再赘述。<br>给ArrayList添加元素后，ArrayList的长度（容量）就会自动增加。但是和Array不一样的是，读取ArrayList的长度需要使用ArrayList的Count属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(arrayListTest.Count);</span><br><span class="line">//将 System.Collections.ICollection 的元素添加到 System.Collections.ArrayList 的末尾。</span><br></pre></td></tr></table></figure></p><h5 id="使用ArrayList中的元素"><a href="#使用ArrayList中的元素" class="headerlink" title="使用ArrayList中的元素"></a>使用ArrayList中的元素</h5><p>添加完元素后，就可以使用里面的元素了。ArrayList可以像Array一样直接用下标索引使用元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassTest classTestObject2 = new ClassTest();</span><br><span class="line">arrayListTest[1] = classTestObject2;</span><br></pre></td></tr></table></figure></p><p>当然，索引ArrayList的下标也不能越界。<br>在使用ArrayList里的对象时，要注意：ArrayList集合是System.Object对象的集合，因此在使用对象成员时需要进行类型转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((ClassTest)arrayListTest[0]).FunctionTest();</span><br><span class="line">//FunctionTest()方法定义在ClassTest中。</span><br></pre></td></tr></table></figure></p><h5 id="删除ArrayList中的元素"><a href="#删除ArrayList中的元素" class="headerlink" title="删除ArrayList中的元素"></a>删除ArrayList中的元素</h5><p>使用如下方法可以删除ArrayList中的特定索引值的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayListTest.RemoveAt(0);</span><br><span class="line">//将删除下标为0的元素</span><br></pre></td></tr></table></figure></p><p>还可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayListTest.Remove(classTestObject);</span><br><span class="line">//删除arrayTest中的classTestObject对象</span><br></pre></td></tr></table></figure></p><p>删除某些元素后，这些元素后面的元素会自动前移。所以务必注意越界问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文参考自《C#入门经典（第八版）》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ArrayList的概述&quot;&gt;&lt;a href=&quot;#ArrayList的概述&quot; class=&quot;headerlink&quot; title=&quot;ArrayList的概述&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/04/08/hello-world/"/>
    <id>http://yoursite.com/2019/04/08/hello-world/</id>
    <published>2019-04-08T08:36:21.000Z</published>
    <updated>2019-04-12T15:01:57.703Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
