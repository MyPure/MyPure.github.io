{"meta":{"title":"MyPure's Blog Station","subtitle":"sqrt(-1) love you!","description":"MyPure's Blog Station","author":"My_Pure","url":"http://yoursite.com","root":"/"},"pages":[{"title":"testpage","date":"2019-04-09T08:36:27.000Z","updated":"2019-04-09T08:36:28.000Z","comments":true,"path":"testpage/index.html","permalink":"http://yoursite.com/testpage/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux命令大全","slug":"linuxcommand","date":"2019-04-12T15:03:08.000Z","updated":"2019-04-12T15:13:12.856Z","comments":true,"path":"2019/04/12/linuxcommand/","link":"","permalink":"http://yoursite.com/2019/04/12/linuxcommand/","excerpt":"","text":"来源 https://www.cnblogs.com/yjd_hycf_space/p/7730690.html 系统信息arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)logout 注销 文件和目录cd /home 进入 ‘/ home’ 目录’cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls *[0-9]* 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构(1)lstree 显示文件和目录由根目录开始的树形结构(2)mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/* . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)file file1 outputs the mime type of the file as texticonv -l 列出已知的编码iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. 文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name *.rpm -exec chmod 755 ‘{}’ \\; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出fuser -km /mnt/hda2 当设备繁忙时强制卸载umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用mount /dev/fd0 /mnt/floppy 挂载一个软盘mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrommount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrommount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrommount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令 (只允许root执行)chage -E 2005-12-31 user1 设置用户口令的失效期限pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限chown user1 file1 改变一个文件的所有人属性chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性chgrp group1 file1 改变文件的群组chown user1:group1 file1 改变一个文件的所有人和群组属性find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s /bin/file1 禁用一个二进制文件的 SUID位chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s /home/public 禁用一个目录的 SGID 位chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件chattr +c file1 允许这个文件能被内核自动压缩/解压chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接chattr +s file1 允许一个文件被安全地删除chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件lsattr 显示特殊的属性 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg “System Environment/Daemons” 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name –whatprovides 显示一个rpm包所占的体积rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本lrpm -q package_name –changelog 显示一个rpm包的修改历史rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书rpm –checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包apt-cdrom install package_name 从光盘安装/更新一个 deb 包apt-get update 升级列表中的软件包apt-get upgrade 升级所有已安装的软件apt-get remove package_name 从系统删除一个deb包apt-get check 确认依赖的软件仓库正确apt-get clean 从下载的软件包中清理缓存apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"C# IComparable和IComparer接口和自定义比较器","slug":"Compare","date":"2019-04-09T08:36:21.000Z","updated":"2019-04-12T15:06:08.158Z","comments":true,"path":"2019/04/09/Compare/","link":"","permalink":"http://yoursite.com/2019/04/09/Compare/","excerpt":"","text":"前言ArrayList里面有一个方法：123public virtual void Sort(IComparer comparer);使用指定的比较器对整个 System.Collections.ArrayList 中的元素进行排序。comparer:比较元素时要使用的 System.Collections.IComparer 实现。 啥玩意啊？ 正文1.Comparer类简单介绍想弄清楚这个，我们先来看看这么一个类。在System.Collections名称空间中，有这么一个类：Comparer。顾名思义，他可以实现对简单类型的比较，什么意思呢？来看如下代码：1int a=1,b=2; 正常情况下，我们要怎样比较他们的大小？if，运算符，……？这当然可以，不过Comparer已经给我们提供了一个函数，可以直接使用：（需要using System.Collections;）1Console.WriteLine(Comparer.Default.Compare(a,b)); 因为a&lt;b，所以控制台会输出-1。（这个函数总是返回-1，0，1三个值。）这里通过Comparer里的静态属性Default获得Comparer的实例调用了Comparer里的非静态函数Compare。（还可以比较根据字母比较两个string类型，这里就省略介绍了） 2.自定义比较器，IComparable，IComparer接口当然，这个类不仅仅只是用来比较两个数的大小的。有时候我们想直接比较两个对象，但是引用里面的属性或许比较麻烦。尤其是参考要素过多，不好直接比较的时候，怎样才能更高效地比较两个对象呢？这时候，我们就需要自定义比较器了。首先来介绍IComparable接口。这个接口里只有一个方法CompareTo()。让你的类实现这个接口的CompareTo方法，就可以直接调用这个方法和另一个对象比较。下面是例子：123456789public class ClassTest : IComparable&#123; public int intTest; public int CompareTo(object obj) &#123; return intTest-((ClassTest)obj).intTest; //这里的代码可以按需要自己编写，这里只是一个简单的示例 &#125;&#125; 然后就可以直接使用啦：123ClassTest a = new ClassTest()&#123;intTest=1&#125;;ClassTest b = new ClassTest()&#123;intTest=2&#125;;Console.WriteLine(a.CompareTo(b));//输出-1 Comparer类已经为我们提供了IComparer的默认实现，但我们仍然可以自定义它。新建一个类：（记得using System.Collections;）12345678910public class ClassTestComparer : IComparer&#123; public static IComparer Default = new ClassTestComparer(); //这里必须使用这样的定义，将对象转化为IComparer类型有很大用处，下面会介绍 public int Compare(object a,object b) &#123; return ((ClassTest)a).intTest - ((ClassTest)b).intTest; //同样这里使用最简单的示例，但是你可以大放异彩 &#125;&#125; 注意，如果用于比较的类和设定的类不一样，就会出现错误。使用示例：1234ClassTest a = new ClassTest()&#123;intTest=1&#125;;ClassTest b = new ClassTest()&#123;intTest=2&#125;;Console.WriteLine(ClassTestComparer.Default.Compare(a,b));//结果是-1 可以发现，这两个接口的不同之处在于：IComparable在要比较的对象的类中实现，可以比较该对象和另一个对象。IComparer在一个单独的类中实现，可以比较任意两个对象（关键是你的设置）。 3.对集合排序当然，这两个接口还有更强大的用处。我们可以使用这两个接口对集合进行排序。还记得前言里的Sort()方法吗？接下来就以ArrayList为例，介绍如何使用。1234567891011ArrayList ClassTests = new ArrayList();ClassTest a = new ClassTest()&#123;intTest=1&#125;;ClassTest b = new ClassTest()&#123;intTest=2&#125;;ClassTest c = new ClassTest()&#123;intTest=3&#125;;ClassTests.Add(a);ClassTests.Add(b);ClassTests.Add(c);ClassTests.Sort();//使用无参的Sort，将调用类中的CompareTo()方法，因为ClassTest实现了这个方法，所以是可以调用的。如果没有实现，编译器会报错。ClassTests.Sort(ClassTestComparer.Default);//这将使用Compare()方法对集合中的元素排序。ClassTestComparer类实现了这个方法，并且提供了一个IComparer类型的属性。 需要注意的是： 两个接口提供的方法返回值都是int类型的，负数代表小于，0代表等于，正数代表大于。所以对数字之外的自定义比较器，需要人工设定什么是“大”，什么是“小”。所以上文示例中两个数直接相减，就可以比较大小。 排序完之后，按照返回的int值，集合是由小到大排列的。 使用无参Sort()时，集合中至少要有一个类实现了IComparable，否则会报错。 一般来说，都是对同一个类进行比较。不过，也可以实现对不同类比较的代码，这就看具体需要了。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Hi","slug":"Hi","date":"2019-04-08T16:48:28.000Z","updated":"2019-04-09T03:45:52.000Z","comments":true,"path":"2019/04/09/Hi/","link":"","permalink":"http://yoursite.com/2019/04/09/Hi/","excerpt":"","text":"I’m MyPure.","categories":[],"tags":[{"name":"你好","slug":"你好","permalink":"http://yoursite.com/tags/你好/"}]},{"title":"ArrayList简介","slug":"ArrayList-Sketch","date":"2019-04-08T16:30:20.000Z","updated":"2019-04-09T08:48:18.000Z","comments":true,"path":"2019/04/09/ArrayList-Sketch/","link":"","permalink":"http://yoursite.com/2019/04/09/ArrayList-Sketch/","excerpt":"","text":"本文参考自《C#入门经典（第八版）》 ArrayList的概述我们知道的普通数组System.Array类实际上是集合类（Collection Class）的一种类型。集合类一般用于处理对象列表，其功能比简单数组要多，功能大多是通过实现System.Collections名称空间中的接口而获得的。而System.Collections.ArrayList类（以下简称ArrayList类）就是这样一种类，可以实现比Array类更多的功能。12345678//在vs中通过按住Alt左键点击ArrayList可以看到namespace System.Collections&#123; public class ArrayList : IList, ICollection, IEnumerable, ICloneable &#123; ...... &#125;&#125; 可以看到ArrayList类使用了IList, ICollection, IEnumerable, ICloneable这四个接口。这几个接口定义在System.Collections名称空间下。这些接口为类提供了基本的集合功能。在说明ArrayList的功能之前，有必要了解一下这几个接口。 IEnumerable——可以迭代（遍历）集合中的项（元素）。 ICollection——继承于IEnumerable。可以获取集合中项的个数，并能把项复制到一个简单的数组类型中。 IList——继承于ICollection和IEnumerable。提供了集合的项列表，允许访问这些项，并提供其他一些与项列表相关的基本功能。 ICloneable——克隆的支持，将创建的类的新实例得到与现有实例相同的值。ArrayList的使用注意：ArrayList里的元素都是System.Object类型的。 ArrayList类实现了上述接口，但实现方式比System.Array类更复杂。这个类可用于表示可变大小的数组（或者称为集合）。接下来将简单介绍使用方法。使用ArrayList前，需要添加System.Collections名称空间。using System.Collections; 创建一个ArrayListArrayList的构造函数有三个重载，下面逐一说明。默认的构造函数是这样的：1ArrayList arrayListTest = new ArrayList(); 可以发现，ArrayList不像普通数组那样需要指定数组的大小。第二个构造函数：12ArrayList arrayListTest = new ArrayList(5);//这样创建的ArrayList默认有五个元素的容量，但这并不是绝对容量。 第三个构造函数是这样的：123public ArrayList(ICollection c);//初始化 System.Collections.ArrayList 类的新实例，该类包含从指定集合复制的元素，并具有与复制的元素数相同的初始容量。//参数c:其元素已复制到新列表的 System.Collections.ICollection。 可以看到c是一个ICollection类型的变量。也就是说，使用了ICollection接口的类的实例都可以当做参数c（没错，普通数组Array也可以，因为Array也使用了ICollection接口）。 所以我们可以这么用：12ArrayList arrayListTest2 = new ArrayList(arrayListTest);//这样创建直接复制了arrayListTest集合 还可以这么用：12int[] intTest = new int[5] &#123; 1, 2, 3, 4, 5 &#125;;ArrayList arrayListTest2 = new ArrayList(intTest); 给ArrayList添加元素不像普通数组定义出来后就有了大小，ArrayList刚创建时是空的（一个元素都没有，除非你不是用的默认构造函数）。那么我们就需要给ArrayList添加元素了。添加元素需要使用ArrayList里的一个方法：12public virtual int Add(object value);//将value对象添加到ArrayList的结尾处。返回值为添加到ArrayList里的value的索引。 使用示例：1234ClassTest classTestObject = new ClassTest();arrayListTest.Add(classTestObject);或者把以上两行代码二合一：arrayListTest.Add(new ClassTest()); Add()方法只能在末尾添加一个元素。因此可以使用另一个方法一次性添加多个元素：12public virtual void AddRange(ICollection c);//将 ICollection 的元素添加到 System.Collections.ArrayList 的末尾。 ICollection接口已在上文介绍，这里不再赘述。给ArrayList添加元素后，ArrayList的长度（容量）就会自动增加。但是和Array不一样的是，读取ArrayList的长度需要使用ArrayList的Count属性。12Console.WriteLine(arrayListTest.Count);//将 System.Collections.ICollection 的元素添加到 System.Collections.ArrayList 的末尾。 使用ArrayList中的元素添加完元素后，就可以使用里面的元素了。ArrayList可以像Array一样直接用下标索引使用元素。12ClassTest classTestObject2 = new ClassTest();arrayListTest[1] = classTestObject2; 当然，索引ArrayList的下标也不能越界。在使用ArrayList里的对象时，要注意：ArrayList集合是System.Object对象的集合，因此在使用对象成员时需要进行类型转换：12((ClassTest)arrayListTest[0]).FunctionTest();//FunctionTest()方法定义在ClassTest中。 删除ArrayList中的元素使用如下方法可以删除ArrayList中的特定索引值的元素：12arrayListTest.RemoveAt(0);//将删除下标为0的元素 还可以使用：12arrayListTest.Remove(classTestObject);//删除arrayTest中的classTestObject对象 删除某些元素后，这些元素后面的元素会自动前移。所以务必注意越界问题。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-04-08T08:36:21.000Z","updated":"2019-04-12T15:01:57.703Z","comments":true,"path":"2019/04/08/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}