{"meta":{"title":"MyPure's Blog Station","subtitle":"sqrt(-1) love you!","description":"MyPure's Blog Station","author":"My_Pure","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"C++ 有序容器关键字类型的“严格弱序”","slug":"strict-weak-ordering","date":"2021-04-02T08:37:05.000Z","updated":"2021-04-02T08:53:47.869Z","comments":true,"path":"2021/04/02/strict-weak-ordering/","link":"","permalink":"http://yoursite.com/2021/04/02/strict-weak-ordering/","excerpt":"","text":"有序容器中的关键字类型当使用一些库函数时，会要求提供自定义的函数比较大小，或是类要重载&lt;运算符。该运算符需要有“严格弱序”（strict weak ordering）的性质。这个性质需要满足： 若两个关键字分别为k1，k2，符号为&lt;，则 若k1&lt;k2为true，则k2&lt;k1为false。 若k1&lt;k2且k2&lt;k3为true，则k1&lt;k3为true。 若k1&lt;k2为false且k2&lt;k1为false，称k1和k2等价，若k1和k2等价，k2和k3等价，则k1和k3等价。 为什么要满足这个性质提供自定义的函数比较大小的时候，只需要提供一个判断便能得出两个变量的大小关系。而条件就是比较大小的运算符满足了“严格弱序”。 举个例子，数值比较的&lt;运算符就满足这个性质，而&lt;=不满足。当判断两个数值变量i1，i2是否相等时，是这样判断的： !(i1&lt;i2) &amp;&amp; !(i2&lt;i1)两个数字都不“严格弱序”于对方，相等。 如果把&lt;换成&lt;=，则会出现错误。因此，有序容器中的关键字类型比较需要满足“严格弱序”。 C++ Primer P378","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"并查集介绍和模板","slug":"UnionFind","date":"2021-03-31T04:36:25.000Z","updated":"2021-03-31T04:38:20.016Z","comments":true,"path":"2021/03/31/UnionFind/","link":"","permalink":"http://yoursite.com/2021/03/31/UnionFind/","excerpt":"","text":"并查集有关并查集的介绍：https://zhuanlan.zhihu.com/p/93647900/ 123456789101112131415161718192021222324252627282930313233343536373839// 并查集模板class UnionFind &#123;public: vector&lt;int&gt; parent; vector&lt;int&gt; size; int n; // 当前连通分量数目 int setCount; public: UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) &#123; iota(parent.begin(), parent.end(), 0); &#125; int findset(int x) &#123; return parent[x] == x ? x : parent[x] = findset(parent[x]); &#125; bool unite(int x, int y) &#123; x = findset(x); y = findset(y); if (x == y) &#123; return false; &#125; if (size[x] &lt; size[y]) &#123; swap(x, y); &#125; parent[y] = x; size[x] += size[y]; --setCount; return true; &#125; bool connected(int x, int y) &#123; x = findset(x); y = findset(y); return x == y; &#125;&#125;;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"biphase","slug":"biphase","date":"2021-03-29T16:00:00.000Z","updated":"2021-05-14T14:58:07.343Z","comments":true,"path":"2021/03/30/biphase/","link":"","permalink":"http://yoursite.com/2021/03/30/biphase/","excerpt":"","text":"生涯首个独立游戏《Biphase》现已推出！《Biphase》是我作为主程序参与开发的一个由大学生团队独立研发的2D平台跳跃解谜游戏。现已在AppStore、GooglePlay、Steam上线，免费游玩！详情请见游戏官网。","categories":[],"tags":[{"name":"Game","slug":"Game","permalink":"http://yoursite.com/tags/Game/"}]},{"title":"不用递归实现二叉树的前中后序遍历","slug":"TreeOrder","date":"2021-03-28T11:57:34.000Z","updated":"2021-03-31T04:36:26.663Z","comments":true,"path":"2021/03/28/TreeOrder/","link":"","permalink":"http://yoursite.com/2021/03/28/TreeOrder/","excerpt":"","text":"不用递归实现二叉树的前中后序遍历前序遍历和中序遍历类似，通过对一个栈的维护即可实现。后序遍历稍有不同，需要记录每一个节点是否访问过右子结点，若访问过则才会出栈并输出该结点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;using namespace std;struct TreeNode &#123; int val; TreeNode* left; TreeNode* right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) &#123;&#125;&#125;; void preorder(TreeNode* root) &#123; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; do &#123; while (cur != nullptr) &#123; cout &lt;&lt; cur-&gt;val &lt;&lt; \" \"; stack.push(cur); cur = cur-&gt;left; &#125; cur = stack.top()-&gt;right; stack.pop(); &#125; while (!stack.empty() || cur != nullptr); cout &lt;&lt; endl;&#125;void inorder(TreeNode* root) &#123; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; do &#123; while (cur != nullptr) &#123; stack.push(cur); cur = cur-&gt;left; &#125; cur = stack.top(); cout &lt;&lt; cur-&gt;val &lt;&lt; \" \"; cur = cur-&gt;right; stack.pop(); &#125; while (!stack.empty() || cur != nullptr); cout &lt;&lt; endl;&#125;void postorder(TreeNode* root) &#123; stack&lt;TreeNode*&gt; stack; map&lt;TreeNode*, bool&gt; map; TreeNode* cur = root; do &#123; while (cur != nullptr) &#123; stack.push(cur); map[cur] = false; cur = cur-&gt;left; &#125; if (!map[stack.top()]) &#123; map[stack.top()] = true; cur = stack.top()-&gt;right; &#125; else &#123; cout &lt;&lt; stack.top()-&gt;val &lt;&lt; \" \"; stack.pop(); &#125; &#125; while (!stack.empty() || cur != nullptr); cout &lt;&lt; endl;&#125;int main()&#123; TreeNode* root = new TreeNode(1); root-&gt;left = new TreeNode(2); root-&gt;left-&gt;left = new TreeNode(4); root-&gt;left-&gt;right = new TreeNode(5); root-&gt;left-&gt;right-&gt;left = new TreeNode(8); root-&gt;left-&gt;right-&gt;right = new TreeNode(9); root-&gt;right = new TreeNode(3); root-&gt;right-&gt;left = new TreeNode(6); root-&gt;right-&gt;right = new TreeNode(7); preorder(root); inorder(root); postorder(root);&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"Unity 有关CanvasScaler缩放后的RectTransform坐标和屏幕坐标问题","slug":"About-CanvasScaler","date":"2021-01-04T09:26:11.000Z","updated":"2021-01-04T09:34:26.094Z","comments":true,"path":"2021/01/04/About-CanvasScaler/","link":"","permalink":"http://yoursite.com/2021/01/04/About-CanvasScaler/","excerpt":"","text":"Unity 有关CanvasScaler缩放后的RectTransform坐标和屏幕坐标问题有的时候，我们希望通过直接设置RectTransform的值来进行UI的调整（例如anchoredPosition），但是由于CanvasScaler的缩放，屏幕坐标和Canvas内的坐标存在一个缩放关系。当想直接设置时，需要弄清楚CanvasScaler的缩放原理，找到坐标之间的对应关系。 有关CanvasScaler的介绍，可以参阅官方文档： https://docs.unity.cn/cn/2019.4/Manual/script-CanvasScaler.html 对于CanvasScaler的理解，可以认为：CanvasScaler的缩放是UI物体不变，画布的大小在变化（实际上也是这样，在缩小屏幕后，Canvas的RectTransform.rect会变大）。CanvasScaler的Match Width Or Height模式中，画布是根据当前屏幕大小和Reference Resolution设置的值进行比较，根据Match中的值来计算实际缩放因子。缩放因子可以通过如下代码计算：1float ScaleFactor =&gt; Screen.width / canvasScaler.referenceResolution.x * (1 - canvasScaler.matchWidthOrHeight) + Screen.height / canvasScaler.referenceResolution.y * canvasScaler.matchWidthOrHeight; 含义是：Canvas内的UI被缩放成原来的UI乘以ScaleFactor的大小。那么，当我们想通过anchoredPosition设置UI的值时，就需要将屏幕坐标除以ScalerFactor，就能计算出UI在画布内的实际坐标。测试场景：创建Canvas，将CanvasScaler的ScreenMatchMode设置为MatchWidthOrHeight。 创建Image，设置RectTransform为锚点模式，并且将锚点设置在左下角。（为了直观与屏幕坐标对应，屏幕坐标的左下角为(0,0)） 为Image创建脚本，完整代码： 12345678910111213141516using UnityEngine;using UnityEngine.UI;using UnityEngine.EventSystems;public class UIDragger : MonoBehaviour,IDragHandler&#123; public Canvas canvas; public CanvasScaler canvasScaler; public RectTransform rectTransform;//Image的RectTransform private float ScaleFactor =&gt; Screen.width / canvasScaler.referenceResolution.x * (1 - canvasScaler.matchWidthOrHeight) + Screen.height / canvasScaler.referenceResolution.y * canvasScaler.matchWidthOrHeight; public void OnDrag(PointerEventData eventData) &#123; rectTransform.anchoredPosition = eventData.position / ScaleFactor; &#125;&#125; 设置好引用后，开始场景，可以看到无论CanvasScaler的Match值设置成什么，都可以正常拖拽。 如果没有经过缩放因子的修正，效果是这样的： 1rectTransform.anchoredPosition = eventData.position; 后半段展示了关掉CanvasScaler的效果，实际上这个时候屏幕坐标就和画布坐标一一对应了。","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"Untiy 多平台宏定义","slug":"PlatformDependentCompilation","date":"2020-11-19T08:03:54.000Z","updated":"2020-11-19T08:11:25.605Z","comments":true,"path":"2020/11/19/PlatformDependentCompilation/","link":"","permalink":"http://yoursite.com/2020/11/19/PlatformDependentCompilation/","excerpt":"","text":"Unity常用多平台宏定义 Define Function UNITY_EDITOR #define directive to call Unity Editor scripts from your game code. UNITY_EDITOR_WIN #define directive for Editor code on Windows. UNITY_EDITOR_OSX #define directive for Editor code on Mac OS X. UNITY_EDITOR_LINUX #define directive for Editor code on Linux. UNITY_STANDALONE_OSX #define directive to compile or execute code specifically for Mac OS X (including Universal, PPC and Intel architectures). UNITY_STANDALONE_WIN #define directive for compiling/executing code specifically for Windows standalone applications. UNITY_STANDALONE_LINUX #define directive for compiling/executing code specifically for Linux standalone applications. UNITY_STANDALONE #define directive for compiling/executing code for any standalone platform (Mac OS X, Windows or Linux). UNITY_WII #define directive for compiling/executing code for the Wii console. UNITY_IOS #define directive for compiling/executing code for the iOS platform. UNITY_ANDROID #define directive for the Android platform. UNITY_PS4 #define directive for running PlayStation 4 code. UNITY_XBOXONE #define directive for executing Xbox One code. UNITY_LUMIN #define directive for the Magic Leap OS platform. You can also use PLATFORM_LUMIN. UNITY_TIZEN #define directive for the Tizen platform. UNITY_TVOS #define directive for the Apple TV platform. UNITY_WSA #define directive for Universal Windows Platform . Additionally, NETFX_CORE is defined when compiling C# files against .NET Core and using .NET scripting backend . UNITY_WSA_10_0 #define directive for Universal Windows Platform. Additionally WINDOWS_UWP is defined when compiling C# files against .NET Core. UNITY_WINRT Same as UNITY_WSA. UNITY_WINRT_10_0 Equivalent to UNITY_WSA_10_0 UNITY_WEBGL #define directive for WebGL . UNITY_FACEBOOK #define directive for the Facebook platform (WebGL or Windows standalone). UNITY_ANALYTICS #define directive for calling Unity Analytics methods from your game code. Version 5.2 and above. UNITY_ASSERTIONS #define directive for assertions control process. UNITY_64 #define directive for 64-bit platforms. 使用示例1234567891011121314151617181920212223242526using UnityEngine;using System.Collections;public class PlatformDefines : MonoBehaviour &#123; void Start () &#123; #if UNITY_EDITOR Debug.Log(&quot;Unity Editor&quot;); #endif #if UNITY_IOS Debug.Log(&quot;Iphone&quot;); #endif #if UNITY_STANDALONE_WIN Debug.Log(&quot;Stand Alone Windows&quot;); #endif #if UNITY_EDITOR Debug.Log(&quot;Unity Editor&quot;); #elif UNITY_IOS Debug.Log(&quot;Unity iPhone&quot;); #else Debug.Log(&quot;Any other platform&quot;); #endif &#125; &#125; 更多，请详阅： https://docs.unity3d.com/Manual/PlatformDependentCompilation.html","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"本科回顾","slug":"University-Days","date":"2020-10-21T13:32:07.000Z","updated":"2021-04-02T09:11:23.546Z","comments":true,"path":"2020/10/21/University-Days/","link":"","permalink":"http://yoursite.com/2020/10/21/University-Days/","excerpt":"","text":"大一 2018.9~2019.6Part1 初见怀揣着加入游戏行业梦想的我，进入了软件学院。军训过后（大概是9月底），参加了软件学院科创团队的招新宣讲，报名了Game组。团队给出了入门任务：实现一个双向链表的数据结构，带有增删改查等功能。从0基础开始，在中秋和国庆期间自学C语言，完成了任务。第二期任务是做一个贪吃蛇。突发奇想地想到了一个上下左右都相连的十字链表型数据结构，最终简单完成了在命令行上的贪吃蛇。可以说这是人生做的第一款游戏。https://github.com/MyPure/Command-Line-Snake第三期任务是用Unity做一个简单的Demo。由于难度跨度太大，没能很好的完成，最后遗憾没有成功加入团队。 Part2 熟悉C语言下发了祖传的贪吃蛇课设。又是贪吃蛇。有了之前的经验，这次我想做一个更好的贪吃蛇。带有图形化的界面，完整的游戏流程、UI、音乐贴图资源、更好的操控以及存档等功能。没日没夜地做了一个多月，总算是完成了（半成品）。https://github.com/MyPure/Snake Part3 学习时间来到了大一下学期。为了准备联创Game组的春招，我开始疯狂地学习C#和Unity。经过十几天的努力，我总算完全掌握入门了C#和Unity。经过了笔试/面试/熬测/群面流程，最终成功进入了Game组。经过了一系列新人任务的洗礼，对Unity引擎Gameplay、计算机图形学、计算机网络都有了一点点入门和了解。在这期间，参加了2019网易Minigame挑战赛，在差不多一个月的时间内和其他人合作完成了一个游戏Demo。这是人生的第一个合作游戏作品。虽然没有成功晋级，但是却是一个很重要的开始。https://game.academy.163.com/activity/miniGame/2019/showcase/detail?id=79 Part4 攀登大一下学期结束后，迎来了软件学院的工程实训。担任队长以及主程，使用Unity引擎，和队员一起完成了一个平台跳跃的小游戏。由于先前有了经验，这次遇到的困难小了很多。第一次设计和实现了游戏的整体运行框架、游戏存档、游戏关卡、游戏UI等等。是一次很有意义的实践。https://github.com/MyPure/yuangungun 大二 2019.9~2020.6Part1 课业大二的上学期课程量猛增。数据结构，汇编语言，Java三门专业课，每一门都自带课设，有的还有附加的大作业。这一年几乎是把所有的精力都放在了课业上，压根没怎么碰游戏开发。惭愧啊。不过作为基础的数据结构还是很重要的。 Part2 转变大二下学期，突如其来的疫情把所有人困在了家里。正因如此拥有了大量充足的课余时间。我开始着手准备今后用于面试的项目，也算是积累一些项目经验。目光放在了小时候玩的一款flash游戏，叫做“海盗军团抢宝藏”，我打算用Unity做一个3D的复刻版。从头开始，做游戏设计、系统设计、三维建模、Gameplay实现、网络编程等等，目标是做出一个完善且完整的项目。包含资源系统、战斗系统、网络系统、音效系统、武器系统、角色系统、地图系统、服务器等等……是一个对编程能力和熟悉Unity引擎提升非常大的项目。 Part3 里程碑大概五月，偶然在实习僧看到了一个叫做“西山居Seed训练营”的宣传。刚好在做着项目，于是就投了简历试试。大概过了半个多月，收到了面试通知，最后成功通过了。这是一个非常有意义的时刻。算是职业生涯的起点了吧。 训练营的内容是业内大佬上课以及自由组队做游戏。作为主程，经过半个月和组内大佬们的努力，我们成功地把游戏做了出来，并且获得了最佳游戏奖。西山居还会支持我们继续完善项目，直到最终完成并且上线。这是一段非常宝贵的经历，不仅技术得到提升，而且能够有机会从业内的视角，进一步了解这个行业。之后拿到了大三去西山居实习的Offer。 大三 2020.9~2021.6Part1 项目经历了大半年的开发，《双相》终于开发完，于2021.3.31上线了！ 期间了解到游戏发行的很多方面，受益匪浅啊。 作为主程，也是第一次做独立游戏，还是遇到了非常多的困难。 多语言、多平台、手柄、音频、演出，都是我第一次接触，在慢慢摸索，自己搭建框架的过程中，克服困难的同时也确实学习到了很多。","categories":[],"tags":[{"name":"career","slug":"career","permalink":"http://yoursite.com/tags/career/"}]},{"title":"UnityEditor","slug":"UnityEditor","date":"2020-09-27T07:57:59.000Z","updated":"2020-10-28T04:46:04.023Z","comments":true,"path":"2020/09/27/UnityEditor/","link":"","permalink":"http://yoursite.com/2020/09/27/UnityEditor/","excerpt":"","text":"UnityEditor扩展一、特性（Attribute）1.1简介特性是C#的一种“装饰”代码的方法，让我们可以为代码段标记一些信息，这样的信息又可从外部读取，并通过各种方式来影响我们所定义的类型的使用方式。添加特性的方式十分简单，将特性名称用中括号括起来，写在代码段前面即可。 1.2创建特性todo 1.3Unity特性","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"Unity_Plug-ins","slug":"Unity-Plug-ins","date":"2019-09-09T11:22:58.000Z","updated":"2020-11-26T14:37:40.699Z","comments":true,"path":"2019/09/09/Unity-Plug-ins/","link":"","permalink":"http://yoursite.com/2019/09/09/Unity-Plug-ins/","excerpt":"","text":"Behavior Designer 用于写AI DoTween 用于补间 PT Default Playable 用于给Timeline添加更多类型的轨道","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"C#笔记","slug":"CSharp-Note","date":"2019-05-06T05:10:22.000Z","updated":"2020-10-28T04:32:07.332Z","comments":true,"path":"2019/05/06/CSharp-Note/","link":"","permalink":"http://yoursite.com/2019/05/06/CSharp-Note/","excerpt":"","text":"字符串函数：ToUpper(); ToLower(); Equals();比较//string变量1.Equals(string变量2); Split();分割 Substring();截取 IndexOf();查找第一次出现 LastIndexOf();查找最后一次出现 StartsWith();判断是否以某字符串开始 EndsWith();判断是否以某字符串结束 Replace();替换 Contains();判断是否包含//string变量.Contains(string变量); Trim();去掉空格//string变量.Trim(); TrimEnd(); TrimStart(); IsNullOrEmpty();判断字符串是Null还是空字符串//string.IsNullOrEmpty(string变量); string.Format();字符串格式化 数组函数： Copyto(Array array,int index);//从指定的目标索引处开始复制当前数组至指定数组 StringBuilder类：using System.Text StringBuilder 变量名 = new StringBuilder(); Append(string变量);追加 ToString();转为string Clear();清空 Stopwatch类：using System.Diagnostics Stopwatch 变量名 = new Stopwatch(); Start();开始 Stop();结束 Elapsed;开始到结束的时间 ArrayList类：using System.Collections;ArrayList 变量名 = new ArrayList();//初始化 System.Collections.ArrayList 类的新实例，该实例为空并且具有默认初始容量 ArrayList 变量名 = new ArrayList(int capacity);//初始化 System.Collections.ArrayList 类的新实例，该实例为空并且具有指定的初始容量 //capacity:新列表最初可以存储的元素数 ArrayList 变量名 = new ArrayList(ICollection c);//初始化 System.Collections.ArrayList 类的新实例，该类包含从指定集合复制的元素，并具有与复制的元素数相同的初始容量 // ICollection:一个接口，带有这个接口的变量都可以使用，例如Array（普通数组）或者ArrayList的对象 Add(object value); 将对象添加到 System.Collections.ArrayList 的结尾处 AddRange(ICollection c);将System.Collections.ICollection 的元素添加到System.Collections.ArrayList 的末尾 //添加新项后，集合中的项数就会增加，此时就可以通过像普通数组那样的常规方法使用集合中的项 Remove(object obj); 从 System.Collections.ArrayList 中移除特定对象的第一个匹配项 RemoveAt(int index); 移除 System.Collections.ArrayList 的指定索引处的元素 Reverse();将整个ArrayList反转 //可以用foreach迭代（遍历）普通数组，也可以迭代ArrayList，因为ArrayList实现了IEnumerable. //要得到ArrayList元素的个数，需要使用Count属性.该属性由ICollection接口提供. 即：Arraylist变量.Count; //ArrayList集合是System.Object对象的集合，所以使用每个实例元素前需要进行类型转换. //这是一个集合类，事实上普通数组Array也是一个集合类. is和as对象变量 is 类; 如果是，值为true，否则值为false 对象变量 as 类;如果是，值为对象，否则为null 类[访问修饰符] class 类名{}; 嵌套类：类可以嵌套 匿名类：不需要定义类就可以实例对象 var 对象名 = new {} 匿名类是只读的 密封类：不可以被继承的类 [访问修饰符] sealed class 类名{} 字段：类中的变量 [访问修饰符] 数据类型 字段名 属性：保护字段 public 数据类型(对应字段的) 属性名(与对应字段名保持一致，首字母大写) { get {return 字段名;}//取值 set {字段名 = value;}//赋值 } 自动属性 public 数据类型 属性名{get;set;}//自动属性不需要对应字段 方法：类中的函数 普通方法：普通的方法 [访问修饰符] 数据类型 方法名(参数){语句} 构造方法：对对象进行初始化，在实例化时调用 [访问修饰符] 类名(){语句} 析构方法：清理一个对象，系统自动调用 ~类名(){语句} 类的继承 [访问修饰符] class 子类名:父类名{} 构造方法的继承 [访问修饰符] class 子类名:base(){} 多态：子类继承父类后的多种形态，存在于继承前提下 虚方法 父类中：public virtual 类型 方法名(){} 子类中：public override 类型 方法名(){} 抽象类 abstract class 类名{} 抽象方法：无方法体的方法 public abstract 类型 方法名(); //抽象类中不一定有抽象方法，但抽象方法必须在抽象类中 //抽象类的子类中必须重写抽象类中的所有抽象方法 //抽象类不可以实例化 接口//一种类的形式，该类为抽象类且所有方法都是抽象方法 interface 接口名{} //接口名一般为I开头 //接口中不能包含字段，但是可以使用属性（自动属性） //接口中的成员没有访问修饰符，默认访问级别都是public //接口中的方法都是抽象方法，没有方法体，但不需要用abstract关键字 //重写接口中的方法时不需要用override关键字 object类所有类都继承于object类，经常在类中重写ToString方法 对象：由类实例化出来的具体事物类名 对象名 = new 类名(); 对象初始化器 类名 对象名 = new 类名(){属性1=xxx,属性名2=xxx…} 访问访问（类） 无或internal：只能在当前项目中访问类 public：可以在任何地方访问类 继承修饰符（类） abstrac：不能实例化，只能被继承 sealed：不能被继承，只能实例化 访问（字段、属性、方法） private：只能在本类中访问 public：任何地方都可以访问 internal：只能在本项目中访问 protected：只能在本类和子类中访问 protected internal：只能在本项目中的本类和子类中访问 静态（static）静态属于类，而不属于实例对象 静态字段 [访问修饰符] static 数据类型 字段名 在定义字段的类型前加static关键字 静态字段只能用类名.字段名才可以访问，对象名.字段名无法访问 静态字段可以直接赋值 静态字段在内存中只存在一份（相当于全局变量） 静态属性 [访问修饰符] static 数据类型 属性名 只能用与封装静态字段 静态方法 [访问修饰符] static 类型 方法名{} 静态方法中不可以调用非静态方法 静态构造方法 static 类名(){} 静态构造方法用于初始化静态成员 一个类只能有一个静态构造方法，没有任何访问修饰符，没有参数 可以定义在静态类中，也可以定义在非静态类中 静态构造方法会在程序创建第一个实例或者引用任何静态成员之前被调用 不能直接调用，由系统调用 静态类 在class前添加static关键字 静态类中不能存在非静态成员 静态类不能实例化对象 运算符重载：可以直接对对象使用运算符给类中添加运算符类型成员： public static 返回值类型 operator 运算符(参数列表){} //成员必须是公开且静态的 //至少要有一个类类型的参数 可以重载的运算符： 一元：+,-,!,~,++,--,true,false 二元：+,-,*,/,%,&amp;,|,^,&lt;&lt;,&gt;&gt; 比较：==,!=,&lt;,&gt;,&lt;=,&gt;= //如果重载true和false运算符，就可以在布尔表达式中使用类 //&gt;和&lt;,&lt;=和&gt;=必须成对重载 单例设计模式1. 声明一个静态且私有的，当前类类型的字段 private static类名 instance; 2. 创建私有无参构造方法，保证外部无法实例化这个类 private 类名(){} 3. 创建一个该类类型的静态方法，用于创建此类的唯一对象 public static 类名 方法名(){ if(instance==null){ instance = new 类名(); } return instance; } 面向对象原则里式转换原则1.子类对象可以直接赋值给父类类型变量 //接口和抽象类都不能直接实例化，但可以声明这些类型的变量 2.子类对象可以调用父类中的成员，但是父类对象只能调用自己的成员 3.如果父类对象中装的是子类对象，可以将这个父类对象强制转换为子类对象 #region 介绍… #endregion","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://yoursite.com/categories/CSharp/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Linux命令大全","slug":"linuxcommand","date":"2019-04-12T15:03:08.000Z","updated":"2019-04-12T15:13:35.785Z","comments":true,"path":"2019/04/12/linuxcommand/","link":"","permalink":"http://yoursite.com/2019/04/12/linuxcommand/","excerpt":"","text":"来源 https://www.cnblogs.com/yjd_hycf_space/p/7730690.html 系统信息arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)logout 注销 文件和目录cd /home 进入 ‘/ home’ 目录’cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls *[0-9]* 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构(1)lstree 显示文件和目录由根目录开始的树形结构(2)mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/* . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)file file1 outputs the mime type of the file as texticonv -l 列出已知的编码iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. 文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name *.rpm -exec chmod 755 ‘{}’ \\; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出fuser -km /mnt/hda2 当设备繁忙时强制卸载umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用mount /dev/fd0 /mnt/floppy 挂载一个软盘mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrommount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrommount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrommount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令 (只允许root执行)chage -E 2005-12-31 user1 设置用户口令的失效期限pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限chown user1 file1 改变一个文件的所有人属性chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性chgrp group1 file1 改变文件的群组chown user1:group1 file1 改变一个文件的所有人和群组属性find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s /bin/file1 禁用一个二进制文件的 SUID位chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s /home/public 禁用一个目录的 SGID 位chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件chattr +c file1 允许这个文件能被内核自动压缩/解压chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接chattr +s file1 允许一个文件被安全地删除chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件lsattr 显示特殊的属性 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg “System Environment/Daemons” 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name –whatprovides 显示一个rpm包所占的体积rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本lrpm -q package_name –changelog 显示一个rpm包的修改历史rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书rpm –checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包apt-cdrom install package_name 从光盘安装/更新一个 deb 包apt-get update 升级列表中的软件包apt-get upgrade 升级所有已安装的软件apt-get remove package_name 从系统删除一个deb包apt-get check 确认依赖的软件仓库正确apt-get clean 从下载的软件包中清理缓存apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"C# IComparable和IComparer接口和自定义比较器","slug":"Compare","date":"2019-04-09T08:36:21.000Z","updated":"2020-10-28T04:45:19.192Z","comments":true,"path":"2019/04/09/Compare/","link":"","permalink":"http://yoursite.com/2019/04/09/Compare/","excerpt":"","text":"前言ArrayList里面有一个方法：123public virtual void Sort(IComparer comparer);使用指定的比较器对整个 System.Collections.ArrayList 中的元素进行排序。comparer:比较元素时要使用的 System.Collections.IComparer 实现。 啥玩意啊？ 正文1.Comparer类简单介绍想弄清楚这个，我们先来看看这么一个类。在System.Collections名称空间中，有这么一个类：Comparer。顾名思义，他可以实现对简单类型的比较，什么意思呢？来看如下代码：1int a=1,b=2; 正常情况下，我们要怎样比较他们的大小？if，运算符，……？这当然可以，不过Comparer已经给我们提供了一个函数，可以直接使用：（需要using System.Collections;）1Console.WriteLine(Comparer.Default.Compare(a,b)); 因为a&lt;b，所以控制台会输出-1。（这个函数总是返回-1，0，1三个值。）这里通过Comparer里的静态属性Default获得Comparer的实例调用了Comparer里的非静态函数Compare。（还可以比较根据字母比较两个string类型，这里就省略介绍了） 2.自定义比较器，IComparable，IComparer接口当然，这个类不仅仅只是用来比较两个数的大小的。有时候我们想直接比较两个对象，但是引用里面的属性或许比较麻烦。尤其是参考要素过多，不好直接比较的时候，怎样才能更高效地比较两个对象呢？这时候，我们就需要自定义比较器了。首先来介绍IComparable接口。这个接口里只有一个方法CompareTo()。让你的类实现这个接口的CompareTo方法，就可以直接调用这个方法和另一个对象比较。下面是例子：123456789public class ClassTest : IComparable&#123; public int intTest; public int CompareTo(object obj) &#123; return intTest-((ClassTest)obj).intTest; //这里的代码可以按需要自己编写，这里只是一个简单的示例 &#125;&#125; 然后就可以直接使用啦：123ClassTest a = new ClassTest()&#123;intTest=1&#125;;ClassTest b = new ClassTest()&#123;intTest=2&#125;;Console.WriteLine(a.CompareTo(b));//输出-1 Comparer类已经为我们提供了IComparer的默认实现，但我们仍然可以自定义它。新建一个类：（记得using System.Collections;）12345678910public class ClassTestComparer : IComparer&#123; public static IComparer Default = new ClassTestComparer(); //这里必须使用这样的定义，将对象转化为IComparer类型有很大用处，下面会介绍 public int Compare(object a,object b) &#123; return ((ClassTest)a).intTest - ((ClassTest)b).intTest; //同样这里使用最简单的示例，但是你可以大放异彩 &#125;&#125; 注意，如果用于比较的类和设定的类不一样，就会出现错误。使用示例：1234ClassTest a = new ClassTest()&#123;intTest=1&#125;;ClassTest b = new ClassTest()&#123;intTest=2&#125;;Console.WriteLine(ClassTestComparer.Default.Compare(a,b));//结果是-1 可以发现，这两个接口的不同之处在于：IComparable在要比较的对象的类中实现，可以比较该对象和另一个对象。IComparer在一个单独的类中实现，可以比较任意两个对象（关键是你的设置）。 3.对集合排序当然，这两个接口还有更强大的用处。我们可以使用这两个接口对集合进行排序。还记得前言里的Sort()方法吗？接下来就以ArrayList为例，介绍如何使用。1234567891011ArrayList ClassTests = new ArrayList();ClassTest a = new ClassTest()&#123;intTest=1&#125;;ClassTest b = new ClassTest()&#123;intTest=2&#125;;ClassTest c = new ClassTest()&#123;intTest=3&#125;;ClassTests.Add(a);ClassTests.Add(b);ClassTests.Add(c);ClassTests.Sort();//使用无参的Sort，将调用类中的CompareTo()方法，因为ClassTest实现了这个方法，所以是可以调用的。如果没有实现，编译器会报错。ClassTests.Sort(ClassTestComparer.Default);//这将使用Compare()方法对集合中的元素排序。ClassTestComparer类实现了这个方法，并且提供了一个IComparer类型的属性。 需要注意的是： 两个接口提供的方法返回值都是int类型的，负数代表小于，0代表等于，正数代表大于。所以对数字之外的自定义比较器，需要人工设定什么是“大”，什么是“小”。所以上文示例中两个数直接相减，就可以比较大小。 排序完之后，按照返回的int值，集合是由小到大排列的。 使用无参Sort()时，集合中至少要有一个类实现了IComparable，否则会报错。 一般来说，都是对同一个类进行比较。不过，也可以实现对不同类比较的代码，这就看具体需要了。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://yoursite.com/categories/CSharp/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"ArrayList简介","slug":"ArrayList-Sketch","date":"2019-04-08T16:30:20.000Z","updated":"2020-10-28T04:45:04.640Z","comments":true,"path":"2019/04/09/ArrayList-Sketch/","link":"","permalink":"http://yoursite.com/2019/04/09/ArrayList-Sketch/","excerpt":"","text":"本文参考自《C#入门经典（第八版）》 ArrayList的概述我们知道的普通数组System.Array类实际上是集合类（Collection Class）的一种类型。集合类一般用于处理对象列表，其功能比简单数组要多，功能大多是通过实现System.Collections名称空间中的接口而获得的。而System.Collections.ArrayList类（以下简称ArrayList类）就是这样一种类，可以实现比Array类更多的功能。12345678//在vs中通过按住Alt左键点击ArrayList可以看到namespace System.Collections&#123; public class ArrayList : IList, ICollection, IEnumerable, ICloneable &#123; ...... &#125;&#125; 可以看到ArrayList类使用了IList, ICollection, IEnumerable, ICloneable这四个接口。这几个接口定义在System.Collections名称空间下。这些接口为类提供了基本的集合功能。在说明ArrayList的功能之前，有必要了解一下这几个接口。 IEnumerable——可以迭代（遍历）集合中的项（元素）。 ICollection——继承于IEnumerable。可以获取集合中项的个数，并能把项复制到一个简单的数组类型中。 IList——继承于ICollection和IEnumerable。提供了集合的项列表，允许访问这些项，并提供其他一些与项列表相关的基本功能。 ICloneable——克隆的支持，将创建的类的新实例得到与现有实例相同的值。ArrayList的使用注意：ArrayList里的元素都是System.Object类型的。 ArrayList类实现了上述接口，但实现方式比System.Array类更复杂。这个类可用于表示可变大小的数组（或者称为集合）。接下来将简单介绍使用方法。使用ArrayList前，需要添加System.Collections名称空间。using System.Collections; 创建一个ArrayListArrayList的构造函数有三个重载，下面逐一说明。默认的构造函数是这样的：1ArrayList arrayListTest = new ArrayList(); 可以发现，ArrayList不像普通数组那样需要指定数组的大小。第二个构造函数：12ArrayList arrayListTest = new ArrayList(5);//这样创建的ArrayList默认有五个元素的容量，但这并不是绝对容量。 第三个构造函数是这样的：123public ArrayList(ICollection c);//初始化 System.Collections.ArrayList 类的新实例，该类包含从指定集合复制的元素，并具有与复制的元素数相同的初始容量。//参数c:其元素已复制到新列表的 System.Collections.ICollection。 可以看到c是一个ICollection类型的变量。也就是说，使用了ICollection接口的类的实例都可以当做参数c（没错，普通数组Array也可以，因为Array也使用了ICollection接口）。 所以我们可以这么用：12ArrayList arrayListTest2 = new ArrayList(arrayListTest);//这样创建直接复制了arrayListTest集合 还可以这么用：12int[] intTest = new int[5] &#123; 1, 2, 3, 4, 5 &#125;;ArrayList arrayListTest2 = new ArrayList(intTest); 给ArrayList添加元素不像普通数组定义出来后就有了大小，ArrayList刚创建时是空的（一个元素都没有，除非你不是用的默认构造函数）。那么我们就需要给ArrayList添加元素了。添加元素需要使用ArrayList里的一个方法：12public virtual int Add(object value);//将value对象添加到ArrayList的结尾处。返回值为添加到ArrayList里的value的索引。 使用示例：1234ClassTest classTestObject = new ClassTest();arrayListTest.Add(classTestObject);或者把以上两行代码二合一：arrayListTest.Add(new ClassTest()); Add()方法只能在末尾添加一个元素。因此可以使用另一个方法一次性添加多个元素：12public virtual void AddRange(ICollection c);//将 ICollection 的元素添加到 System.Collections.ArrayList 的末尾。 ICollection接口已在上文介绍，这里不再赘述。给ArrayList添加元素后，ArrayList的长度（容量）就会自动增加。但是和Array不一样的是，读取ArrayList的长度需要使用ArrayList的Count属性。12Console.WriteLine(arrayListTest.Count);//将 System.Collections.ICollection 的元素添加到 System.Collections.ArrayList 的末尾。 使用ArrayList中的元素添加完元素后，就可以使用里面的元素了。ArrayList可以像Array一样直接用下标索引使用元素。12ClassTest classTestObject2 = new ClassTest();arrayListTest[1] = classTestObject2; 当然，索引ArrayList的下标也不能越界。在使用ArrayList里的对象时，要注意：ArrayList集合是System.Object对象的集合，因此在使用对象成员时需要进行类型转换：12((ClassTest)arrayListTest[0]).FunctionTest();//FunctionTest()方法定义在ClassTest中。 删除ArrayList中的元素使用如下方法可以删除ArrayList中的特定索引值的元素：12arrayListTest.RemoveAt(0);//将删除下标为0的元素 还可以使用：12arrayListTest.Remove(classTestObject);//删除arrayTest中的classTestObject对象 删除某些元素后，这些元素后面的元素会自动前移。所以务必注意越界问题。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://yoursite.com/categories/CSharp/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]}