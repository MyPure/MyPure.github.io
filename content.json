{"meta":{"title":"MyPure's Blog Station","subtitle":"sqrt(-1) love you!","description":"MyPure's Blog Station","author":"My_Pure","url":"http://yoursite.com","root":"/"},"pages":[{"title":"testpage","date":"2019-04-09T08:36:27.000Z","updated":"2019-04-09T08:36:28.000Z","comments":true,"path":"testpage/index.html","permalink":"http://yoursite.com/testpage/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-04-12T13:15:29.590Z","updated":"2019-04-09T03:45:52.000Z","comments":true,"path":"2019/04/12/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"C# IComparable和IComparer接口和自定义比较器","slug":"Compare","date":"2019-04-09T08:36:21.000Z","updated":"2019-04-09T09:36:58.000Z","comments":true,"path":"2019/04/09/Compare/","link":"","permalink":"http://yoursite.com/2019/04/09/Compare/","excerpt":"","text":"前言ArrayList里面有一个方法：123public virtual void Sort(IComparer comparer);使用指定的比较器对整个 System.Collections.ArrayList 中的元素进行排序。comparer:比较元素时要使用的 System.Collections.IComparer 实现。 啥玩意啊？ 正文1.Comparer类简单介绍想弄清楚这个，我们先来看看这么一个类。在System.Collections名称空间中，有这么一个类：Comparer。顾名思义，他可以实现对简单类型的比较，什么意思呢？来看如下代码：1int a=1,b=2; 正常情况下，我们要怎样比较他们的大小？if，运算符，……？这当然可以，不过Comparer已经给我们提供了一个函数，可以直接使用：（需要using System.Collections;）1Console.WriteLine(Comparer.Default.Compare(a,b)); 因为a&lt;b，所以控制台会输出-1。（这个函数总是返回-1，0，1三个值。）这里通过Comparer里的静态属性Default获得Comparer的实例调用了Comparer里的非静态函数Compare。（还可以比较根据字母比较两个string类型，这里就省略介绍了） 2.自定义比较器，IComparable，IComparer接口当然，这个类不仅仅只是用来比较两个数的大小的。有时候我们想直接比较两个对象，但是引用里面的属性或许比较麻烦。尤其是参考要素过多，不好直接比较的时候，怎样才能更高效地比较两个对象呢？这时候，我们就需要自定义比较器了。首先来介绍IComparable接口。这个接口里只有一个方法CompareTo()。让你的类实现这个接口的CompareTo方法，就可以直接调用这个方法和另一个对象比较。下面是例子：123456789public class ClassTest : IComparable&#123; public int intTest; public int CompareTo(object obj) &#123; return intTest-((ClassTest)obj).intTest; //这里的代码可以按需要自己编写，这里只是一个简单的示例 &#125;&#125; 然后就可以直接使用啦：123ClassTest a = new ClassTest()&#123;intTest=1&#125;;ClassTest b = new ClassTest()&#123;intTest=2&#125;;Console.WriteLine(a.CompareTo(b));//输出-1 Comparer类已经为我们提供了IComparer的默认实现，但我们仍然可以自定义它。新建一个类：（记得using System.Collections;）12345678910public class ClassTestComparer : IComparer&#123; public static IComparer Default = new ClassTestComparer(); //这里必须使用这样的定义，将对象转化为IComparer类型有很大用处，下面会介绍 public int Compare(object a,object b) &#123; return ((ClassTest)a).intTest - ((ClassTest)b).intTest; //同样这里使用最简单的示例，但是你可以大放异彩 &#125;&#125; 注意，如果用于比较的类和设定的类不一样，就会出现错误。使用示例：1234ClassTest a = new ClassTest()&#123;intTest=1&#125;;ClassTest b = new ClassTest()&#123;intTest=2&#125;;Console.WriteLine(ClassTestComparer.Default.Compare(a,b));//结果是-1 可以发现，这两个接口的不同之处在于：IComparable在要比较的对象的类中实现，可以比较该对象和另一个对象。IComparer在一个单独的类中实现，可以比较任意两个对象（关键是你的设置）。 3.对集合排序当然，这两个接口还有更强大的用处。我们可以使用这两个接口对集合进行排序。还记得前言里的Sort()方法吗？接下来就以ArrayList为例，介绍如何使用。1234567891011ArrayList ClassTests = new ArrayList();ClassTest a = new ClassTest()&#123;intTest=1&#125;;ClassTest b = new ClassTest()&#123;intTest=2&#125;;ClassTest c = new ClassTest()&#123;intTest=3&#125;;ClassTests.Add(a);ClassTests.Add(b);ClassTests.Add(c);ClassTests.Sort();//使用无参的Sort，将调用类中的CompareTo()方法，因为ClassTest实现了这个方法，所以是可以调用的。如果没有实现，编译器会报错。ClassTests.Sort(ClassTestComparer.Default);//这将使用Compare()方法对集合中的元素排序。ClassTestComparer类实现了这个方法，并且提供了一个IComparer类型的属性。 需要注意的是： 两个接口提供的方法返回值都是int类型的，负数代表小于，0代表等于，正数代表大于。所以对数字之外的自定义比较器，需要人工设定什么是“大”，什么是“小”。所以上文示例中两个数直接相减，就可以比较大小。 排序完之后，按照返回的int值，集合是由小到大排列的。 使用无参Sort()时，集合中至少要有一个类实现了IComparable，否则会报错。 一般来说，都是对同一个类进行比较。不过，也可以实现对不同类比较的代码，这就看具体需要了。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"test","slug":"test","date":"2019-04-09T03:22:15.000Z","updated":"2019-04-09T03:45:52.000Z","comments":true,"path":"2019/04/09/test/","link":"","permalink":"http://yoursite.com/2019/04/09/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hi","slug":"Hi","date":"2019-04-08T16:48:28.000Z","updated":"2019-04-09T03:45:52.000Z","comments":true,"path":"2019/04/09/Hi/","link":"","permalink":"http://yoursite.com/2019/04/09/Hi/","excerpt":"","text":"I’m MyPure.","categories":[],"tags":[{"name":"你好","slug":"你好","permalink":"http://yoursite.com/tags/你好/"}]},{"title":"ArrayList简介","slug":"ArrayList-Sketch","date":"2019-04-08T16:30:20.000Z","updated":"2019-04-09T08:48:18.000Z","comments":true,"path":"2019/04/09/ArrayList-Sketch/","link":"","permalink":"http://yoursite.com/2019/04/09/ArrayList-Sketch/","excerpt":"","text":"本文参考自《C#入门经典（第八版）》 ArrayList的概述我们知道的普通数组System.Array类实际上是集合类（Collection Class）的一种类型。集合类一般用于处理对象列表，其功能比简单数组要多，功能大多是通过实现System.Collections名称空间中的接口而获得的。而System.Collections.ArrayList类（以下简称ArrayList类）就是这样一种类，可以实现比Array类更多的功能。12345678//在vs中通过按住Alt左键点击ArrayList可以看到namespace System.Collections&#123; public class ArrayList : IList, ICollection, IEnumerable, ICloneable &#123; ...... &#125;&#125; 可以看到ArrayList类使用了IList, ICollection, IEnumerable, ICloneable这四个接口。这几个接口定义在System.Collections名称空间下。这些接口为类提供了基本的集合功能。在说明ArrayList的功能之前，有必要了解一下这几个接口。 IEnumerable——可以迭代（遍历）集合中的项（元素）。 ICollection——继承于IEnumerable。可以获取集合中项的个数，并能把项复制到一个简单的数组类型中。 IList——继承于ICollection和IEnumerable。提供了集合的项列表，允许访问这些项，并提供其他一些与项列表相关的基本功能。 ICloneable——克隆的支持，将创建的类的新实例得到与现有实例相同的值。ArrayList的使用注意：ArrayList里的元素都是System.Object类型的。 ArrayList类实现了上述接口，但实现方式比System.Array类更复杂。这个类可用于表示可变大小的数组（或者称为集合）。接下来将简单介绍使用方法。使用ArrayList前，需要添加System.Collections名称空间。using System.Collections; 创建一个ArrayListArrayList的构造函数有三个重载，下面逐一说明。默认的构造函数是这样的：1ArrayList arrayListTest = new ArrayList(); 可以发现，ArrayList不像普通数组那样需要指定数组的大小。第二个构造函数：12ArrayList arrayListTest = new ArrayList(5);//这样创建的ArrayList默认有五个元素的容量，但这并不是绝对容量。 第三个构造函数是这样的：123public ArrayList(ICollection c);//初始化 System.Collections.ArrayList 类的新实例，该类包含从指定集合复制的元素，并具有与复制的元素数相同的初始容量。//参数c:其元素已复制到新列表的 System.Collections.ICollection。 可以看到c是一个ICollection类型的变量。也就是说，使用了ICollection接口的类的实例都可以当做参数c（没错，普通数组Array也可以，因为Array也使用了ICollection接口）。 所以我们可以这么用：12ArrayList arrayListTest2 = new ArrayList(arrayListTest);//这样创建直接复制了arrayListTest集合 还可以这么用：12int[] intTest = new int[5] &#123; 1, 2, 3, 4, 5 &#125;;ArrayList arrayListTest2 = new ArrayList(intTest); 给ArrayList添加元素不像普通数组定义出来后就有了大小，ArrayList刚创建时是空的（一个元素都没有，除非你不是用的默认构造函数）。那么我们就需要给ArrayList添加元素了。添加元素需要使用ArrayList里的一个方法：12public virtual int Add(object value);//将value对象添加到ArrayList的结尾处。返回值为添加到ArrayList里的value的索引。 使用示例：1234ClassTest classTestObject = new ClassTest();arrayListTest.Add(classTestObject);或者把以上两行代码二合一：arrayListTest.Add(new ClassTest()); Add()方法只能在末尾添加一个元素。因此可以使用另一个方法一次性添加多个元素：12public virtual void AddRange(ICollection c);//将 ICollection 的元素添加到 System.Collections.ArrayList 的末尾。 ICollection接口已在上文介绍，这里不再赘述。给ArrayList添加元素后，ArrayList的长度（容量）就会自动增加。但是和Array不一样的是，读取ArrayList的长度需要使用ArrayList的Count属性。12Console.WriteLine(arrayListTest.Count);//将 System.Collections.ICollection 的元素添加到 System.Collections.ArrayList 的末尾。 使用ArrayList中的元素添加完元素后，就可以使用里面的元素了。ArrayList可以像Array一样直接用下标索引使用元素。12ClassTest classTestObject2 = new ClassTest();arrayListTest[1] = classTestObject2; 当然，索引ArrayList的下标也不能越界。在使用ArrayList里的对象时，要注意：ArrayList集合是System.Object对象的集合，因此在使用对象成员时需要进行类型转换：12((ClassTest)arrayListTest[0]).FunctionTest();//FunctionTest()方法定义在ClassTest中。 删除ArrayList中的元素使用如下方法可以删除ArrayList中的特定索引值的元素：12arrayListTest.RemoveAt(0);//将删除下标为0的元素 还可以使用：12arrayListTest.Remove(classTestObject);//删除arrayTest中的classTestObject对象 删除某些元素后，这些元素后面的元素会自动前移。所以务必注意越界问题。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]}